<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="google-site-verification" content="BTo06tdvlac_Dho4-PFTLmDqjKXr1KtOzavpD8XDA5k" />
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jiechu520.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="日常笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="CJ blog">
<meta property="og:url" content="https://jiechu520.github.io/index.html">
<meta property="og:site_name" content="CJ blog">
<meta property="og:description" content="日常笔记">
<meta property="og:locale">
<meta property="article:author" content="Jie Chu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jiechu520.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CJ blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CJ blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">不知名算法工程师</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jie Chu</p>
  <div class="site-description" itemprop="description">日常笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2024/02/09/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/09/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">图像生成模型综述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-09 21:00:00" itemprop="dateCreated datePublished" datetime="2024-02-09T21:00:00+08:00">2024-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-19 23:08:00" itemprop="dateModified" datetime="2024-02-19T23:08:00+08:00">2024-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">扩散模型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[toc]</p>
<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>为了更好的理解图像生成模型的演化过程，在这里，对这一系列模型进行总结，包括任务场景、评估指标、模型类型、效率优化、局限性等方面分别总结，以便更好地对比和理解。</p>
<h2 id="二、任务场景"><a href="#二、任务场景" class="headerlink" title="二、任务场景"></a>二、任务场景</h2><h3 id="2-1-无条件生成"><a href="#2-1-无条件生成" class="headerlink" title="2.1 无条件生成"></a>2.1 无条件生成</h3><p>生成模型在生成图像时不受<font color=red>任何额外条件或约束的影响</font>。模型从学习的数据分布中生成图像，而不需要关注输入条件。</p>
<p>无条件适用于那些不需要额外信息或上下文的场景。例如，针对人脸数据训练，那么就可以输入随机噪声，然后生成逼真的人脸图像，而不用考虑任何特定属性或描述。</p>
<p>CelebA-HQ（人脸）、FFHQ（人脸）、LSUN-Churches（教堂） 和 LSUN-Bedrooms（卧室） 都是常见的无条件评估任务。</p>
<ul>
<li>CelebA-HQ 包含 30,000 1024x1024 分辨率的高质量人脸图像。（<a target="_blank" rel="noopener" href="https://paperswithcode.com/dataset/celeba-hq）">https://paperswithcode.com/dataset/celeba-hq）</a></li>
<li>FFHQ 同样是高质量的人脸数据集，包含 70,000 张 1024x1024 分辨率的高质量人脸图像，有不同的种族、肤色和背景等。（<a target="_blank" rel="noopener" href="https://github.com/NVlabs/ffhq-dataset）">https://github.com/NVlabs/ffhq-dataset）</a></li>
<li>LSUN 数据集包含 10 个场景类别，包括卧室、厨房、教堂等等，每个图像的大小都为 256x256 分辨率，每个类别包含 120,000 到 3,000,000 张图像。</li>
</ul>
<p>如下图所示为分别基于以上数据集训练之后（4 个模型）生成的图像示例（来自 LDM）：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/9ad8b9515f0b4f5cf85f21ad37f9d01a.png" alt="9ad8b9515f0b4f5cf85f21ad37f9d01a"></p>
<h3 id="2-2-有条件生成"><a href="#2-2-有条件生成" class="headerlink" title="2.2 有条件生成"></a>2.2 有条件生成</h3><p>有条件生成可以通过cross attention的方式引入各式各样的条件控制图像生成。</p>
<h4 id="2-2-1-类别条件生成"><a href="#2-2-1-类别条件生成" class="headerlink" title="2.2.1 类别条件生成"></a>2.2.1 类别条件生成</h4><p>类别条件生成是非常常见的一种场景，也有许多相关的任务，其中 ImageNet 是最常见的一种，ImageNet 常用于图像分类任务，每个图像都有一个类别标签，总共有 1000 个类别。在图像生成领域，可以指定对应的类别标签，然后让模型按照类别生成图像。</p>
<h4 id="2-2-2-文本条件生成"><a href="#2-2-2-文本条件生成" class="headerlink" title="2.2.2 文本条件生成"></a>2.2.2 文本条件生成</h4><p>当前最常见的图像生成范式，输入自然语言描述，模型即可生成相应的图像。</p>
<h4 id="2-2-3-位置条件"><a href="#2-2-3-位置条件" class="headerlink" title="2.2.3 位置条件"></a>2.2.3 位置条件</h4><p>有些时候我们会对图像中物体的布局，或主体的位置有特殊的要求，此时可以结合上述的类别条件和文本条件来约束模型。</p>
<p>如下图所示，左侧图中指定了图片中物体的位置关系（以边界框坐标表示），最终模型按要求生成了对应的图像（图片来自 LDM，模型基于 COCO 数据集训练）：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/6f2aa993ca449d9bc52dd72740e46ef6.png" alt="6f2aa993ca449d9bc52dd72740e46ef6"></p>
<h4 id="2-2-4-图像扩充-Outpainting-and-图像内编辑-inpainting"><a href="#2-2-4-图像扩充-Outpainting-and-图像内编辑-inpainting" class="headerlink" title="2.2.4 图像扩充 (Outpainting) and 图像内编辑 (inpainting)"></a>2.2.4 图像扩充 (Outpainting) and 图像内编辑 (inpainting)</h4><p>给定图像，将其扩展为更大的图片；市面上比较火的应用，如 ai扩图，商品图背景生成，基本上都是基于outpainting 的方式。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image%20(9).png" alt="image (9)" style="zoom: 25%;" /><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/tmpi1mj8me6.png" alt="tmpi1mj8me6" style="zoom: 50%;" /></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/c_raw.png" alt="c_raw" style="zoom: 25%;" /><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/tmpiliondnx.png" alt="tmpiliondnx" style="zoom:33%;" /></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/640.gif" alt="640"></p>
<p>inpaint 和 outpaint 模型的训练方式基本相同，都是用文生图模型的权重进行初始化，然后改变 Unet 输入的 channels（5 additional input channels ，4 for the encoded masked-image and 1 for the mask itself）,新增的channels zero-initialized。</p>
<p>但是需要注意的是 inpaint 和 outpaint 训练时的mask方式根据推理时mask的特点而有所不同，二者可以混合在一起训练。</p>
<h4 id="2-2-6-图像内文字生成"><a href="#2-2-6-图像内文字生成" class="headerlink" title="2.2.6 图像内文字生成"></a>2.2.6 图像内文字生成</h4><p>有些时候需要图片中包含特定的文本内容，也可以以条件的形式输入。但是当前大部分文生图的模型直接生成文字效果都不太好 (Dalle3 生成文字比较准确，文字不易变形)</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/3f98ca6187b332eb475ee4ce532c6c5d.png" alt="3f98ca6187b332eb475ee4ce532c6c5d"></p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2309.15807">Meta的文生图模型Emu</a> 采用 channel数更大的VAE可以改善生成文字畸变的情况。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240125163857323.png" alt="image-20240125163857323"></p>
<p>对于文字概念，需要训练数据中的caption描述更加准确和详细。</p>
<h4 id="2-2-7-多种条件生成"><a href="#2-2-7-多种条件生成" class="headerlink" title="2.2.7 多种条件生成"></a>2.2.7 多种条件生成</h4><p>有些场景会包含多种条件，比如给定图像、文本等多种条件，模型综合考量这些条件才能生成满足要求的图像。如下图所示：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/237055b77e0004a0a54bc7fa67b8464d.png" alt="237055b77e0004a0a54bc7fa67b8464d"></p>
<h2 id="三、评估指标"><a href="#三、评估指标" class="headerlink" title="三、评估指标"></a>三、评估指标</h2><p>公司内部模型迭代上线，一般采取人工评测的方式，从开源评测集以及真实用户输入数据中随机按一定比例挑选 prompt 生成图片后，由人工从多个维度如，图文相关性，美观度，合理性等角度进行评测。</p>
<h3 id="3-1-IS-Inception-Score"><a href="#3-1-IS-Inception-Score" class="headerlink" title="3.1 IS (Inception Score)"></a>3.1 IS (Inception Score)</h3><p>IS（Inception Score）：用于评估生成图像质量和多样性的指标。它结合了两个方面的考量：</p>
<ul>
<li>生成图像的真实性（真实图像的概率，在对应类别上的概率应该尽量高）</li>
<li>生成图像的多样性（类别分布的熵，生成不同类别图像应该尽量均匀）</li>
</ul>
<p>IS 的计算方法包含两个步骤：</p>
<ul>
<li>首先，通过分类模型提取生成图像在每个类别的概率分布</li>
<li>然后，计算这些概率分布的 KL 散度，最终的 IS 是这些 KL 散度的指数平均值</li>
</ul>
<h3 id="3-2-FID-Frechet-Inception-Distance"><a href="#3-2-FID-Frechet-Inception-Distance" class="headerlink" title="3.2 FID (Frechet Inception Distance)"></a>3.2 FID (Frechet Inception Distance)</h3><p>FID（Frechet Inception Distance）：用于反映生成图片和真实图片之间的距离，数值越低越好。</p>
<p>FID 的计算方法包含两个步骤：</p>
<ul>
<li>首先，通过模型提取真实图像和生成图像的特征向量。</li>
<li>然后，计算这两个特征向量分布之间的 Frechet 距离，也就是均值和协方差的 Frechet 距离。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/640" alt="图片"></p>
<p>在实际使用中，通常使用 IS 来评估真实性，使用 FID 来评估多样性。</p>
<h3 id="3-3-CMMD"><a href="#3-3-CMMD" class="headerlink" title="3.3 CMMD"></a>3.3 CMMD</h3><p>谷歌在最新的文章 <strong><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2401.09603">Rethinking FID</a></strong> 中提出了一个新的图像生成评估指标，并指出 FID 的缺陷。</p>
<p>code：<a target="_blank" rel="noopener" href="https://github.com/google-research/google-research/tree/master/cmmd">https://github.com/google-research/google-research/tree/master/cmmd</a></p>
<p>FID 估计真实图像的 Inception-v3 特征分布与算法生成的图像的分布之间的距离。FID 的重要缺点：<strong>Inception 对现代文本到图像模型生成的丰富多样的内容的表示不佳、不正确的正态性假设以及样本复杂性较差。</strong></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240204155257324.png" alt="image-20240204155257324"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240125175818071.png" alt="image-20240125175818071"></p>
<h4 id="How-to-Calculate？"><a href="#How-to-Calculate？" class="headerlink" title="How to Calculate？"></a>How to Calculate？</h4><p>CMMD使用了 MMD 距离来计算真实图像分布和生成图像分布之间的距离。对于两个概率分布 $P\in R^d,Q\in R^d$, 相对于正定核 $k$ MMD距离定义如下：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240204160143429.png" alt="image-20240204160143429"></p>
<p>其中 x 和 x’ 独立分布于 P，y 和 y’ 独立分布于 Q。</p>
<p>下面是 官方Jax版本的 CMMD 距离的计算code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Memory-efficient MMD implementation in JAX.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jax</span><br><span class="line"><span class="keyword">import</span> jax.numpy <span class="keyword">as</span> jnp</span><br><span class="line"></span><br><span class="line">Array = jnp.ndarray</span><br><span class="line"></span><br><span class="line"><span class="comment"># The bandwidth parameter for the Gaussian RBF kernel. See the paper for more</span></span><br><span class="line"><span class="comment"># details.</span></span><br><span class="line">_SIGMA = <span class="number">10</span></span><br><span class="line"><span class="comment"># The following is used to make the metric more human readable. See the paper</span></span><br><span class="line"><span class="comment"># for more details.</span></span><br><span class="line">_SCALE = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jax.jit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mmd</span>(<span class="params">x, y</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Memory-efficient MMD implementation in JAX.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    x: The first set of embeddings of shape (n, embedding_dim).</span></span><br><span class="line"><span class="string">    y: The second set of embeddings of shape (n, embedding_dim).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    The MMD distance between x and y embedding sets.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  x = jnp.asarray(x)</span><br><span class="line">  y = jnp.asarray(y)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># jnp.matmul(x, x.T) etc. are not cached to avoid OOM when x has many rows.</span></span><br><span class="line">  x_sqnorms = jnp.diag(jnp.matmul(x, x.T))</span><br><span class="line">  y_sqnorms = jnp.diag(jnp.matmul(y, y.T))</span><br><span class="line"></span><br><span class="line">  gamma = <span class="number">1</span> / (<span class="number">2</span> * _SIGMA**<span class="number">2</span>)</span><br><span class="line">  k_xx = jnp.mean(</span><br><span class="line">      jnp.exp(</span><br><span class="line">          -gamma</span><br><span class="line">          * (</span><br><span class="line">              -<span class="number">2</span> * jnp.matmul(x, x.T)</span><br><span class="line">              + jnp.expand_dims(x_sqnorms, <span class="number">1</span>)</span><br><span class="line">              + jnp.expand_dims(x_sqnorms, <span class="number">0</span>)</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">  )</span><br><span class="line">  k_xy = jnp.mean(</span><br><span class="line">      jnp.exp(</span><br><span class="line">          -gamma</span><br><span class="line">          * (</span><br><span class="line">              -<span class="number">2</span> * jnp.matmul(x, y.T)</span><br><span class="line">              + jnp.expand_dims(x_sqnorms, <span class="number">1</span>)</span><br><span class="line">              + jnp.expand_dims(y_sqnorms, <span class="number">0</span>)</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">  )</span><br><span class="line">  k_yy = jnp.mean(</span><br><span class="line">      jnp.exp(</span><br><span class="line">          -gamma</span><br><span class="line">          * (</span><br><span class="line">              -<span class="number">2</span> * jnp.matmul(y, y.T)</span><br><span class="line">              + jnp.expand_dims(y_sqnorms, <span class="number">1</span>)</span><br><span class="line">              + jnp.expand_dims(y_sqnorms, <span class="number">0</span>)</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _SCALE * (k_xx + k_yy - <span class="number">2</span> * k_xy)</span><br></pre></td></tr></table></figure>
<h3 id="3-4-CLIP-Score"><a href="#3-4-CLIP-Score" class="headerlink" title="3.4 CLIP Score"></a>3.4 CLIP Score</h3><p>CLIP 模型由 OpenAI 发布，其模型包含一个图像 encoder 和一个文本 encoder，训练的目的是实现图文特征的对齐。因此常用两个 encoder 分别提取文本和图像的 embedding，然后计算相似性得分，距离越大证明相似性越低，也就是图像和文本越不相关。常用于评估模型以文本作为条件生成的图像是否很好满足文本要求。</p>
<h3 id="3-5-DrawBench"><a href="#3-5-DrawBench" class="headerlink" title="3.5 DrawBench"></a>3.5 DrawBench</h3><p>在 Imagen 中，Google 同步提出了 DrawBench，这是一个全面且具有挑战性的文本生成图片模型评测基准。</p>
<p>如下图 Table A.1 所示，DrawBench 基准包含 11 个类别的 200 个文本提示：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/9d6bf15e3563d1b2bef2404e66382764.png" alt="9d6bf15e3563d1b2bef2404e66382764"></p>
<p>针对这个基准的评估，会对每个类别进行独立的人工评估。对于每个提示，评分员都会看到两种图像，一组来自模型 A，一组来自模型 B。每组包含来自相应模型的 8 个随机生成结果，针对每组图像，评分员都会被问两个问题：</p>
<ul>
<li>哪个图像质量更高？</li>
<li>哪个图像与文本描述更匹配？</li>
</ul>
<p>这些问题是为了评估生成图像的质量以及文本-图像匹配度。对于每个问题，评分员都有三种选择：</p>
<ul>
<li>更喜欢 A</li>
<li>无法确定</li>
<li>更喜欢 B</li>
</ul>
<h3 id="3-6-PartiPrompts"><a href="#3-6-PartiPrompts" class="headerlink" title="3.6 PartiPrompts"></a>3.6 PartiPrompts</h3><p>在 Parti 中，Google 作者构建了 PartiPrompts 评估基准，其包含 1600 个英文提示，并将其按照两个维度进行划分：Category 和 Challenge，具体的分布如下所示：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/7b6a1d9ee4ddf9cdc79c3bde46d80cd1.png" alt="7b6a1d9ee4ddf9cdc79c3bde46d80cd1"></p>
<h2 id="四、常用模型"><a href="#四、常用模型" class="headerlink" title="四、常用模型"></a>四、常用模型</h2><h3 id="4-1-模型结构"><a href="#4-1-模型结构" class="headerlink" title="4.1 模型结构"></a>4.1 模型结构</h3><p>图像生成任务中通常会包含几个子模型，常见的结构有 CNN、AutoEncoder、U-net、Transformer 等。</p>
<p>其中 AutoEncoder 模型和 U-Net 模型结构上非常相似，也通常是各种模型的主干。主要不同表现在：</p>
<ul>
<li>AutoEncoder 包含 Encoder 和 Decoder，它们训练完后可以单独使用：<ul>
<li>Encoder 通常用于对输入进行编码（压缩），比如将图像 X 映射到隐空间（Latent Space）L。 </li>
<li>Decoder 通常用于使用编码重构输入（解压缩），比如从隐空间 L 恢复出图像 X。</li>
</ul>
</li>
<li>U-Net：U-Net 模型结构和 AutoEncoder 模型很类似，主要是在 Encoder 和 Decoder 的不同分辨率之间添加了 Skip Connection，如下图所示，也就是说，此时的 Decoder 不仅依赖 Latent code 还依赖输入，也就不能分开单独使用：</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/c249d790a2143bec2be8f4bc5cb9ad54.png" alt="c249d790a2143bec2be8f4bc5cb9ad54"></p>
<h3 id="4-2-VAE"><a href="#4-2-VAE" class="headerlink" title="4.2 VAE"></a>4.2 VAE</h3><p>基于latent的图像生成模型都需要一个 vae 模型，将图片压缩，然后再压缩空间内进行扩散训练。autoencoder是一个基于encoder-decoder架构的图像压缩模型，对于一个大小为 $H\times W \times 3H$的输入图像，encoder模块将其编码为一个大小为 $h\times w \times c$ 的latent，其中$f=H/h=W/h$为下采样率（<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=downsampling factor&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A&quot;2954363993&quot;}">downsampling factor</a>）。在训练autoencoder过程中，除了采用<strong>L1重建损失</strong>外，还增加了<strong>感知损失</strong>（perceptual loss，即LPIPS，具体见论文<a href="https://link.zhihu.com/?target=https%3A//richzhang.github.io/PerceptualSimilarity/">The Unreasonable Effectiveness of Deep Features as a Perceptual Metric</a>）以及<strong>基于patch的对抗训练</strong>。辅助loss主要是为了确保重建的图像局部真实性以及避免模糊，具体损失函数见<a href="https://link.zhihu.com/?target=https%3A//github.com/CompVis/latent-diffusion/tree/main/ldm/modules/losses">latent diffusion的loss部分</a>。同时为了防止得到的latent的标准差过大，采用了两种正则化方法：第一种是<strong>KL-reg</strong>，类似VAE增加一个latent和标准正态分布的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=KL loss&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A&quot;2954363993&quot;}">KL loss</a>，不过这里为了保证重建效果，采用比较小的权重（～10e-6）；第二种是<strong>VQ-reg</strong>，引入一个VQ （vector quantization）layer，此时的模型可以看成是一个VQ-GAN，不过VQ层是在decoder模块中，这里VQ的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=codebook&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A&quot;2954363993&quot;}">codebook</a>采样较高的维度（8192）来降低正则化对重建效果的影响。</p>
<h3 id="4-3-Text-Encoder"><a href="#4-3-Text-Encoder" class="headerlink" title="4.3 Text Encoder"></a>4.3 Text Encoder</h3><h4 id="4-3-1-CLIP模型"><a href="#4-3-1-CLIP模型" class="headerlink" title="4.3.1 CLIP模型"></a>4.3.1 CLIP模型</h4><p>CLIP 是 OpenAI 发布的在大规模图文数据对（4亿）上通过对比学习进行预训练的图文对齐模型。如下图左侧是其对比预训练过程，在一个 batch 中对应的图文特征作为正对，图片特征和其他文本特征作为负对。如下图右侧，可广泛用于 zero-shot 的图像分类等任务。由于其强大的表征能力，其 Text Encoder 和 Image Encoder 常被其他模型使用，用于对图像或文本编码。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/89e07698ff3038a219f065e5c61f9048.png" alt="89e07698ff3038a219f065e5c61f9048"></p>
<h4 id="4-3-2-T5系列"><a href="#4-3-2-T5系列" class="headerlink" title="4.3.2 T5系列"></a>4.3.2 T5系列</h4><p>在 Imagen 中增加语言模型的大小比增加图像扩散模型的大小更能提高样本逼真度以及实现更好的图像-文本对齐。与此类似，Parti 中作者同样发现使用更大的 Text Encoder 可以实现更好的文本-图像对齐。后续的大规模训练的文生图模型通常都采用更大的 Text Encoder如，T5系列。</p>
<p>如下图 Figure A.5 所示为 Imagen 中作者对比的不同大小 T5 模型的影响：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/903fac13d3f00a8f82a2ae9ba3a45307.png" alt="903fac13d3f00a8f82a2ae9ba3a45307"></p>
<h2 id="五、模型类型"><a href="#五、模型类型" class="headerlink" title="五、模型类型"></a>五、模型类型</h2><h3 id="5-1-VAE-系列"><a href="#5-1-VAE-系列" class="headerlink" title="5.1 VAE 系列"></a>5.1 VAE 系列</h3><p>VAE 系列模型的发展大概分为几个阶段，首先是从 AE（AutoEncoder）发展到 VAE（Variational Autoencoder），然后依次出现了 VQ-VAE（Vector Quantised VAE）、VQ-VAE-2 以及 VQ-GAN、ViT-VQGAN 和 MaskGIT 等工作。然而这些工作往往用于无条件生成，或者简单的类别条件、图像条件等，其往往不支持文本输入，或者相关能力很弱。从 21 年初 DALL-E 的发布，文生图的模型开始大量出现，进一步出现 DALL-E mini、 CLIP-VQ-GAN、Parti、Muse 等模型。如下图所示，为这一系列模型的演进路径：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zhVlwj96tThL425ictIF9KibrSibSxxwBTcZ5M5sLp9UDLEFDPNN51mibsHlHsLJdr15PawR6ibAvzNpT3EJhoKQPEw/640?wx_fmt=png&amp;from=appmsg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4 id="5-1-1-AE"><a href="#5-1-1-AE" class="headerlink" title="5.1.1 AE"></a>5.1.1 AE</h4><p>AE（AutoEncoder，可以称作自编码器）是一种人工神经网络，可以用于学习无标签数据的有效编码。AE 的目的是：学习对高维度数据进行低维度表示（Representation），也就是压缩，因此常用于降维。</p>
<p>AutoEncoder 有两个主要的部分组成：</p>
<ul>
<li>Encoder（编码器）：用于对输入进行编码（压缩）</li>
<li>Decoder（解码器）：用于使用编码重构输入（解压缩）</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/fb9f488d416a381068984a8a3551c56a.png" alt="fb9f488d416a381068984a8a3551c56a"></p>
<h4 id="5-1-2-VAE"><a href="#5-1-2-VAE" class="headerlink" title="5.1.2 VAE"></a>5.1.2 VAE</h4><p>VAE （Variational AutoEncoder，也称变分自编码器）主要是在 AE 的基础上引入概率生成模型的概念，通过在隐空间引入概率分布，使模型能够生成多样性的样本，并且在学习过程中可以更好地理解数据的分布。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/a8e276e9d7984e2b4aaf355354d453bb.png" alt="a8e276e9d7984e2b4aaf355354d453bb"></p>
<h4 id="5-1-3-VQ-VAE"><a href="#5-1-3-VQ-VAE" class="headerlink" title="5.1.3 VQ-VAE"></a>5.1.3 VQ-VAE</h4><p>VQ-VAE（Vector Quantization）主要是在 VAE 的基础上引入离散的、可量化的隐空间表示，有助于模型更好地理解数据中的离散结构和语义信息，同时可以避免过拟合。VQ-VAE 与 VAE 的结构非常相似，只是中间部分不是学习概率分布，而是换成 VQ 来学习 Codebook。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/e482da18c0de663daae469b67e28630e.png" alt="e482da18c0de663daae469b67e28630e"></p>
<h4 id="5-1-4-VQ-GAN"><a href="#5-1-4-VQ-GAN" class="headerlink" title="5.1.4 VQ-GAN"></a>5.1.4 VQ-GAN</h4><p>VQ-GAN 相比 VQ-VAE 的主要改变有以下几点：</p>
<ul>
<li>引入 GAN 的思想，将 VQ-VAE 当作生成器（Generator），并加入判别器（Discriminator），以对生成图像的质量进行判断、监督，以及加入感知重建损失（不只是约束像素的差异，还约束 feature map 的差异），以此来重建更具有保真度的图片，也就学习了更丰富的 codebook。</li>
<li>将 PixelCNN 替换为性能更强大的自回归 GPT2 模型（针对不同的任务可以选择不同的规格）。</li>
<li>引入滑动窗口自注意力机制，以降低计算负载，生成更大分辨率的图像。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/2fd67a6c6cd150333e5b67a5e04dc10b.png" alt="2fd67a6c6cd150333e5b67a5e04dc10b"></p>
<h4 id="5-1-5-ViT-VQGAN"><a href="#5-1-5-ViT-VQGAN" class="headerlink" title="5.1.5 ViT-VQGAN"></a>5.1.5 ViT-VQGAN</h4><p>如下图 Figure 1 所示，ViT-VQGAN 的模型结构与 VQGAN 基本一致，主要是将 Encoder 和 Decoder 从 CNN 结构替换为 ViT 模型。</p>
<ul>
<li>Encoder：对应 Patch 大小为 8x8，没有重叠，因此 256x256 的图像会生成 32x32=1024 个 Token 序列。推理阶段不再需要。</li>
<li>Quantization：将 1024 个 Token 序列映射到 Codebook 空间，Codebook 的大小为 8192。</li>
<li>Decoder：从 1024 个离散 Latent code 中恢复原始图像。</li>
<li>Autoregressive Transformer：用于生成离散 Latent code。训练中可以直接利用 Encoder 生成好的离线 Latent code 作为 Target，计算交叉熵损失。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/e3e2d7cf919d5203b5e624890552c6c4.png" alt="e3e2d7cf919d5203b5e624890552c6c4"></p>
<h4 id="5-1-6-Parti"><a href="#5-1-6-Parti" class="headerlink" title="5.1.6 Parti"></a>5.1.6 Parti</h4><p>相比原始的 VQ-GAN 和 ViT-VQGAN 中使用 Decoder Only 的 Transformer 来生成离散 latent code，Parti 中作者将其扩展为 Encoder + Decoder 的 Transformer，这样可以使用 Encoder 来对文本编码，生成文本 embedding，然后文本 embedding 作为条件在 Transformer Decoder 中作为 K 和 V 通过 Cross Attention 与视觉 Token 交叉。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/f68c546ba8ba4a43d1c953b513831e8b.png" alt="f68c546ba8ba4a43d1c953b513831e8b"></p>
<h4 id="5-1-7-MaskGIT"><a href="#5-1-7-MaskGIT" class="headerlink" title="5.1.7 MaskGIT"></a>5.1.7 MaskGIT</h4><p>MaskGIT 采用 VQGAN 的模型范式，与 VQGAN 不同的是，VQGAN 中的 Transformer 采用序列生成的方式，在推理阶段其图像 Token 要一个一个预测，性能比较差，而 MaskGIT 中，Transformer 生成模型采用 Masked Visual Token Modeling 方式来训练（采用类似 Bert 的双向 Transformer 模型），也就是随机遮挡部分图像 Token，模型训练的目标是预测这些遮挡的 Token。以此方式训练的 Transformer 可以充分利用并行解码（Parallel Decoding）方式加速生成效率。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/f5712e7c963de4f73185ac6d7e2be335.png" alt="f5712e7c963de4f73185ac6d7e2be335"></p>
<h4 id="5-1-8-Muse"><a href="#5-1-8-Muse" class="headerlink" title="5.1.8 Muse"></a>5.1.8 Muse</h4><p>Muse 采用预训练的 LLM 提取文本 embedding，和 MaskGIT 一样，被训练用于预测随机 Mask 的图像 Token。作者发现，直接预测 512x512 分辨率的图像会导致模型更关注一些低级的细节，同时发现使用级联模型更有帮助。首先生成 16x16 的 latent map（对应 256x256 分辨率的图像），然后基于 16x16 的 latent map 使用超分模型上采样 64x64 的 latent map（对应 512x512 分辨率的图像）。</p>
<p>如下图 Figure 3 所示为 Muse 模型的整体架构，可以看出，其包含多个组件，主要是三个部分：</p>
<ul>
<li>Text Encoder：用于提取文本 embedding</li>
<li>256x256：低分辨率 Token 预测，包含 VQ Tokenizer 和 Base Transformer</li>
<li>512x512：高分辨率 Token 预测，包含 VQ Tokenizer 和 SuperRes Transformer</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/5a36f94abe364e7042847dc4d2baa2dd.png" alt="5a36f94abe364e7042847dc4d2baa2dd"></p>
<h4 id="5-1-9-DALL-E"><a href="#5-1-9-DALL-E" class="headerlink" title="5.1.9 DALL-E"></a>5.1.9 DALL-E</h4><p>与 VQ-GAN 类似，DALL-E 的训练也是分为两个阶段，第一阶段是训练 VAE，不过并没有使用 VQ-VAE，而是使用 Discrete VAE（dVAE），整体来说与 VQ-VAE 类似，主要的区别是引入 Gumbel Softmax 来训练，避免 VQ-VAE 训练中 ArgMin 不可导的问题。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/8b61b46863918fc922628bc78b04dd19.png" alt="8b61b46863918fc922628bc78b04dd19"></p>
<h4 id="5-1-10-VQGAN-CLIP"><a href="#5-1-10-VQGAN-CLIP" class="headerlink" title="5.1.10 VQGAN-CLIP"></a>5.1.10 VQGAN-CLIP</h4><p>VQGAN-CLIP 的思路很简单：使用初始图像通过 VQ-GAN 生成一个图像，然后使用 CLIP 对生成图像和 Target Text 提取 embedding，然后计算相似性，并将其误差作为反馈对隐空间的 Z-vector 进行迭代更新，直到生成图像和 Target Text 对应的 embedding 很相似为止。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/f086b8acb2025280465b00e48c7388ea.png" alt="f086b8acb2025280465b00e48c7388ea"></p>
<h3 id="5-2-Diffsion-系列"><a href="#5-2-Diffsion-系列" class="headerlink" title="5.2 Diffsion 系列"></a>5.2 Diffsion 系列</h3><p>Diffusion 模型的发展路径如下图所示，主要是 OpenAI 系列模型，Stable Diffusion 系列模型，和 Google 的 Imagen、Imagen 2。其他的开源模型有 kandinsky系列。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/e5b762a35bb56d73325c0d5669166902.png" alt="e5b762a35bb56d73325c0d5669166902"></p>
<h4 id="5-2-1-DDPM"><a href="#5-2-1-DDPM" class="headerlink" title="5.2.1 DDPM"></a>5.2.1 DDPM</h4><p>扩散模型包含两个过程：前向过程（Forward Process，也称为扩散过程 Diffusion Process）和逆向过程（Reverse Process）。无论是前向还是逆向，都是一个马尔科夫链形式（Markov Chain），其中前向过程是不断地向图片中添加高斯噪声，逆向过程是不断地去除高斯噪声，重建图像。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/ff475021fcfb86dd901049005ef4e373.png" alt="ff475021fcfb86dd901049005ef4e373"></p>
<h4 id="5-2-2-Diffusion-Model-Beat-GANS"><a href="#5-2-2-Diffusion-Model-Beat-GANS" class="headerlink" title="5.2.2 Diffusion Model Beat GANS"></a>5.2.2 Diffusion Model Beat GANS</h4><p>这也是 OpenAI 的工作，本文的工作主要有两点：</p>
<ul>
<li>验证了无条件图像生成中不同模型结构对效果的影响，进行了大量的消融实验。</li>
<li>引入 classifier guidance 来提升生成质量。</li>
</ul>
<p>对模型结构的修改主要有以下几个方面：</p>
<ul>
<li>保持模型大小不变，增加深度，降低宽度</li>
<li>增加 Attention 头的数量</li>
<li>不只是在 16x16 分辨率使用 Attention，在 32x32 和 8x8 也使用</li>
<li>在上采样和下采样激活时使用 BigGAN 的 residual block</li>
<li>在 residual connection 中采用 1/sqrt(2) 的缩放</li>
</ul>
<p>如下图 Table 1 所示为不同配置的影响，可以看出，使用更多的 Attention 头、在多个分辨率使用 Attention 以及采用 BigGAN 的 residual block 获得了最好的结果，提出的模型称作 ADM（Ablate Diffusion Model），这个模型也为 OpenAI 后续的生成模型奠定了基础，Stable Diffusion 的模型也有参考：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/ee96a536861dd5c4b7085da4cb11ced6.png" alt="ee96a536861dd5c4b7085da4cb11ced6"></p>
<h4 id="5-2-3-GLIDE"><a href="#5-2-3-GLIDE" class="headerlink" title="5.2.3 GLIDE"></a>5.2.3 GLIDE</h4><p>GLIDE 模型中作者将 Diffusion 模型应用于文本条件图像生成，GLIDE 主要包含两个子模型：</p>
<ul>
<li>文本条件+扩散模型（3.5B）<ul>
<li>Text encoding Transformer（1.2B，24 个 residual block，width 2048）。</li>
<li>扩散模型（64x64 分辨率，2.3B），采用 Diffusion Model Beat GANs 中的 ADM（Ablated Diffusion Model）， width 扩展到 512 channels，并在此基础上扩展了文本条件信息。</li>
</ul>
</li>
<li>文本条件+上采样模型（1.5B）<ul>
<li>和上一步类似的 Text Transformer 模型，不过 width 从 2048 降低到 1024</li>
<li>上采样模型同样来自 ADM-U（分辨率从 64x64 扩展到 256x256，channel 从 192 扩展到 384）</li>
</ul>
</li>
</ul>
<h4 id="5-2-4-DALL-E-2"><a href="#5-2-4-DALL-E-2" class="headerlink" title="5.2.4 DALL-E 2"></a>5.2.4 DALL-E 2</h4><p>在 GLIDE 中尝试了文本引导图像生成，取得了不错的结果。在本文中，作者充分利用强大的 CLIP 模型，提出了一个两阶段图像生成模型，整体的模型结构如下图 Figure 2 所示：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/04493eedf06a325b6b037b1ad0ab65e4.png" alt="04493eedf06a325b6b037b1ad0ab65e4"></p>
<ul>
<li>img encoder：对应 CLIP 模型的 image encoder，给定图像，并生成图像 embedding zi，这个 embedding zi 在训练中用于 prior 生成的 target，也就是训练中 prior 生成的 embedding 要与 CLIP img encoder 生成的 embedding 尽量相似。训练中 img encoder 保持冻结，推理生成阶段不再需要 img encoder。</li>
<li>text encoder：用于在训练阶段和图像生成阶段对文本进行编码，生成 embedding zt，作为 prior 的输入。训练和推理阶段都需要 text encoder，并且始终保持冻结。</li>
<li>prior：用于从文本 embedding zt 生成图像 embedding zi。</li>
<li>decoder：用于从图像 embedding zi 生成最终图像（文本条件为可选项）。</li>
</ul>
<h4 id="5-2-5-DALL-E-3"><a href="#5-2-5-DALL-E-3" class="headerlink" title="5.2.5 DALL-E 3"></a>5.2.5 DALL-E 3</h4><p>DALL-E 3 是 OpenAI 最新的文生图模型，作者发现<strong>传统的文生图模型难以遵循详细的图像描述，并且经常出现忽略单词或混淆提示的语义，作者猜测可能是训练集中的噪声或者不准确的图像描述导致的</strong>。因此，作者首先训练了一个图像描述器，然后生成了一系列高度描述性的图像描述，之后将其用于文生图模型训练，其大大提高了文生图的指令跟随能力。</p>
<p>作者只在附录中用很小的篇幅介绍了 DALL-E 3 的部分模型组件，包括 Image decoder 和 latent decoder。</p>
<p>如下图所示，其 image decoder 参考了 Stable Diffusion 的实现，采用 3 阶段的 latent diffusion 模型。</p>
<ul>
<li>其 VAE 和 Stable Diffusion 一样，都是 8x 的下采样，训练的图像分辨率为 256x256，会生成 32x32 的隐向量。</li>
<li>时间步长条件：采用 GroupNorm，并学习了 scale 和 bias。</li>
<li>文本条件：使用 T5 XXL 作为 text encoder，然后将输出的 embedding 和 xfnet 进行 Cross Attention。在 OpenAI 的 Paper 中并没有找到 xfnet 相关介绍，不过在 GLIDE 的开源代码里确实有 xf model。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/a4d752cf60a335984ffbe6c9be91f277.png" alt="a4d752cf60a335984ffbe6c9be91f277"></p>
<p>如下图所示，作者同样训练了一个 latent decoder，可以用来提升图像细节，比如文本和人脸。其同样是参考 Stable Diffusion 的实现。不过这个 diffusion decoder 采用的是 DDPM 中描述的空间卷积 U-Net，此外，也基于 [2303.01469] Consistency Models 的蒸馏策略将去噪步数降低到 2 步，极大降低推理代价。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/1102103845a6060740450931813e5325.png" alt="1102103845a6060740450931813e5325"></p>
<h4 id="5-2-6-stable-diffusion"><a href="#5-2-6-stable-diffusion" class="headerlink" title="5.2.6 stable diffusion"></a>5.2.6 stable diffusion</h4><p>LDM 和其他扩散生成模型结构类似，整体来说包含三个组件：</p>
<ul>
<li>Auto Encoder：下图左侧部分，包含红框的 Encoder 和蓝框的 Decoder，其中 Encoder 主要用于训练中生成 target z，推理阶段不需要。而 Decoder 用于从隐空间编码（latent code）恢复出图像。</li>
<li>Conditioning：下图右侧部分，用于对各种条件信息进行编码，生成的 embedding 会在扩散模型 U-Net 中使用。不同的条件可能会有不同的 Encoder 模型，也有不同的使用方式（对应下图中的 switch），比如：<ul>
<li>对于文本类型条件，可以使用 Bert Encoder，也可以使用 CLIP 中的 Text Encoder 将文本编码为 embedding。</li>
<li>对于图像类型条件，比如图像修复、分割条件，可以将其编码后与噪声 Concat 作为输入，而不是通过 Attention 机制交叉。</li>
</ul>
</li>
<li>Denoising U-Net：下图中间部分，用于从随机噪声 zT 中通过几步迭代生成 latent code，然后使用 Decoder 恢复出图像。其中的各种条件信息都会通过 Cross Attention 进行交叉融合。需要说明的是，U-Net 生成的目标是 x 经 Encoder 编码后的 embedding，通常也称为隐向量，而不是直接生成图像像素，因此说 U-Net 是作用在隐空间（Latent Space）。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/f301399b271b39302f3e911abacb87f9.png" alt="f301399b271b39302f3e911abacb87f9"></p>
<h4 id="5-2-7-SDXL"><a href="#5-2-7-SDXL" class="headerlink" title="5.2.7 SDXL"></a>5.2.7 SDXL</h4><p>SDXL 相比 SD 主要的修改包括（模型总共 2.6B 参数量，其中 text encoder 817M 参数量）：</p>
<ul>
<li>增加一个 Refiner 模型，用于对图像进一步地精细化。</li>
<li>使用 CLIP ViT-L 和 OpenCLIP ViT-bigG 两个 text encoder。</li>
<li>基于 OpenCLIP 的 text embedding 增加了一个 pooled text embedding。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/59522404e4b0979c96b20996ba69c164.png" alt="59522404e4b0979c96b20996ba69c164"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/a5ab65454a275ac3437cf94401345379.png" alt="a5ab65454a275ac3437cf94401345379"></p>
<h4 id="5-2-8-SDXL-Turbo"><a href="#5-2-8-SDXL-Turbo" class="headerlink" title="5.2.8 SDXL-Turbo"></a>5.2.8 SDXL-Turbo</h4><p>SDXL-Turbo 在模型上没有什么修改，主要是引入蒸馏技术，以便减少 LDM 的生成步数，提升生成速度。大致的流程为：</p>
<ul>
<li>从 Tstudent 中采样步长 s，对于原始图像 x0 进行 s 步的前向扩散过程，生成加噪图像 xs。</li>
<li>使用学生模型 ADD-student 对 xs 进行去噪，生成去噪图像 xθ。</li>
<li>基于原始图像 x0 和去噪图像 xθ 计算对抗损失（adversarial loss）。</li>
<li>从 Tteacher 中采样步长 t，对去噪后的图像 xθ 进行 t 步的前向扩散过程，生成 xθ,t。</li>
<li>使用教师模型 DM-student 对 xθ,t 进行去噪，生成去噪图像 xψ。</li>
<li>基于学生模型去噪图像 xθ 和教师模型去噪图像 xψ 计算蒸馏损失（distillation）。</li>
<li>根据损失进行反向传播（注意，教师模型不更新，因此会 stop 梯度）。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/833e48d05789f1a87502b398912f276c.png" alt="833e48d05789f1a87502b398912f276c"></p>
<h4 id="5-2-9-Imgen"><a href="#5-2-9-Imgen" class="headerlink" title="5.2.9 Imgen"></a>5.2.9 Imgen</h4><p>Imagen 是 Google 推出的基于扩散模型的文生图模型，其具有前所未有的逼真度和深层次的语言理解能力。Imagen 结合了大型 Transformer 语言模型的强大能力和扩散模型的高保真图像生成能力。</p>
<p>整体来说，模型包含四个基础组件：</p>
<ul>
<li>Frozen Text Encoder：将文本编码为 embedding，作者对比了 T5 系列模型和 CLIP 的 text Encoder，最终选择 T5-XXL。</li>
<li>Text-to-Image Diffusion Model：采用 U-Net 结构的 Diffusion 模型，并将步数 t 和上一步的文本 embedding 作为条件。共 2B 参数量。</li>
<li>第一 Super-Resolution Diffusion Model：采用本文优化过的高效 U-Net，将 64x64 图像超分为 256x256 图像，同样使用文本 embedding 作为条件。共 600M 参数量。</li>
<li>第二 Super-Resolution Diffusion Model：采用本文优化过的高效 U-Net，将 256x256 图像超分为 1024x1024 图像，同样使用文本 embedding 作为条件。共 400M 参数量。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/e8c67004fbee80b979088cdf64836973.png" alt="e8c67004fbee80b979088cdf64836973"></p>
<h4 id="5-2-10-wurschen"><a href="#5-2-10-wurschen" class="headerlink" title="5.2.10 wurschen"></a>5.2.10 wurschen</h4><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240218140602925.png" alt="image-20240218140602925"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240218142258132.png" alt="image-20240218142258132"></p>
<p>wurschen 三阶段级联结构，目标的是为了降低训练和推理的计算要求和时间，并且保持生成图像的质量。核心是通过在非常低维的 latent space 上以 42:1 的高压缩比来训练扩散模型来实现。</p>
<ul>
<li>首先使用文本条件的 LDM（阶段 C）以强压缩比创建图像的低维潜在表示。</li>
<li>随后，使用这个潜在表示和text-condition一起调节另一个 LDM（阶段B），产生在更高维度（较少压缩）的潜在空间中的潜在表示，该模型负责进行重建（阶段B）。</li>
<li>最后，通过 VQGAN 解码器对中间分辨率的潜在表示解码，生成完整分辨率的输出图像（阶段A）。</li>
</ul>
<h4 id="5-2-11-stable-cascade"><a href="#5-2-11-stable-cascade" class="headerlink" title="5.2.11 stable cascade"></a>5.2.11 stable cascade</h4><p>stable cascade是基于<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2306.00637">Wuerstchen</a>架构包含三阶段的文生图扩散模型，相比Stable Diffusion XL，它不仅更快而且效果更好。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/%E6%88%AA%E5%9B%BE20240218144038.png" alt="截图20240218144038"></p>
<p>最重要的一个阶段是Stage C，它是一个基于文本作为条件来生成图像的latents的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=扩散模型&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;682257045&quot;}">扩散模型</a>，只不过这里的latents和SD中的latents有些区别，之前的SD是采用一个VAE将图像编码成下采样8x的latents，而这里是采用一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=Semantic Compressor&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;682257045&quot;}">Semantic Compressor</a>来将3×1024×1024的图像压缩成16×24×24的latents，空间下采样约42x，这比SD的VAE要狠的多（不过特征维度高了）。这里的Semantic Compressor采用的是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=EfficientNetV2-S模型&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;682257045&quot;}">EfficientNetV2-S模型</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EfficientNetEncoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c_latent=<span class="number">16</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.backbone = torchvision.models.efficientnet_v2_s(weights=<span class="string">&#x27;DEFAULT&#x27;</span>).features.<span class="built_in">eval</span>()</span><br><span class="line">        self.mapper = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1280</span>, c_latent, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(c_latent, affine=<span class="literal">False</span>),  <span class="comment"># then normalize them to have mean 0 and std 1</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.mapper(self.backbone(x))</span><br></pre></td></tr></table></figure>
<p>对于3x1024x1024的图像，首先resize到3x768x768，然后经过EfficientNetV2-S后得到1280x24x24的特征，这里再额外加了一个Conv和BN层将特征映射为16x24x24。 Stage C的text encoder采用的是OpenCLIP ViT-G，这里是提取了token embeddings（77x1280）以及全局pooled embedding（1x1280），其中pooled embedding映射为4个token特征，和token embeddings拼接在一起送入Stage C的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=UNet&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;682257045&quot;}">UNet</a>作为条件，这里采用的条件机制还是通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=cross- attention&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;682257045&quot;}">cross- attention</a>。此外，Stage C在训练过程中还引入CLIP image encoder的image embedding作为条件，这里是采用openai CLIP ViT-L提取的image embedding，然后映射为4个tokens和text tokens拼接在一起，不过训练过程中对image embedding采用比较大的drop比例（90%）。CLIP image embedding的引入可以让模型类似<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=DALLE-2&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;682257045&quot;}">DALLE-2</a>那样支持image variation。 从本质上看，<strong>这里的Stage C其实就是想当于一个SD主模型（UNet），只不过采用了不同的autoencoder所提取的latents</strong>，相比较而言，Stage C采用了压缩率更大的latents，这也使得模型更高效。这里开源的Stage C也有两个不同大小的版本：一个是1B，一个是3.6B，但是肯定是3.6B的模型效果更好，也是主推模型。</p>
<p>Stage C可以将文本转成图像的latents，要想生成最终的图像，还需要解码器，这就是Stage B和Stage A了。Stage B和Stage A和在一起，就是一个latent decoder，它是将16x24x24的latents解码为一个3x1024x1024的图像，从功能上就相当于SD中的VAE decoder。</p>
<h3 id="5-3-其他开源系列"><a href="#5-3-其他开源系列" class="headerlink" title="5.3 其他开源系列"></a>5.3 其他开源系列</h3><p>kandinsky系列是俄罗斯一个团队开源的文生图模型，致力于多语言条件生成能力。</p>
<h4 id="5-3-1-kandinsky-2-1"><a href="#5-3-1-kandinsky-2-1" class="headerlink" title="5.3.1 kandinsky 2.1"></a>5.3.1 kandinsky 2.1</h4><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/73387ba47854844a67caf6a4003fcbe0.png" alt="img"></p>
<p>如上图所示，kandinsky2.1 结合了 Dalle 和 stable diffusion 中比较有效的结构。</p>
<p>整体来说模型包含五个组件：</p>
<ul>
<li>text-encoder：为了进行多语言生成，kandinsky使用了多语言的文本编码器, XLM-Roberta-Large-Vit-L-14, 参数约 560M。</li>
<li>prior：prior模型采用了 DiT 结构，利用扩散生成的目标来对齐 CLIP文本和图像的embedding。参数约 1B。</li>
<li>CLIP image encoder: 将图像编码成 embedding 作为 prior 训练的 groundtruth。</li>
<li>latent diffusion Unet：此时训练的条件不仅是来自文本的 embedding，也包含以文本为条件通过prior模型产生的 image clip embedding。参数规模约 1.22B。</li>
<li>MoVQ编码器/解码器：将图像编码到 latent space。</li>
</ul>
<h4 id="5-3-2-kandinsky2-2"><a href="#5-3-2-kandinsky2-2" class="headerlink" title="5.3.2 kandinsky2.2"></a>5.3.2 kandinsky2.2</h4><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/dc999237d80ba9b3b6bb782a1012a0e5.png" alt="img"></p>
<p>Kandinsky 2.2 对其前身 Kandinsky 2.1 进行了重大改进，引入了新的、更强大的图像编码器 - CLIP-ViT-G 和 ControlNet 支持。改用 CLIP-ViT-G 作为图像编码器显着提高了模型生成更美观的图片和更好地理解文本的能力，从而提高了模型的整体性能。</p>
<p><strong>架构细节：</strong></p>
<ul>
<li>文本编码器 (XLM-Roberta-Large-Vit-L-14) - 560M</li>
<li>扩散图像先验 — 1B</li>
<li>CLIP 图像编码器 (ViT-bigG-14-laion2B-39B-b160k) - 1.8B</li>
<li>潜在扩散 U-Net - 1.22B</li>
<li>MoVQ编码器/解码器 - 67M</li>
</ul>
<p>另一个相较于 2.1 的重大改进是，<strong>训练 U-net的时候只用 image encoder产生的 embedding 作为条件。</strong></p>
<h4 id="5-3-3-kandinsky-3-0"><a href="#5-3-3-kandinsky-3-0" class="headerlink" title="5.3.3 kandinsky 3.0"></a>5.3.3 kandinsky 3.0</h4><p>kandinksky 3.0 的pipeline包括一个 text encoder， unet，vae</p>
<p>没有采用 kandinsky2.x 和 sdxl 的两段式结构。kandinsky3.0的整体参数量是 kandinsky2.2 的三倍，sdxl的3.6倍，采用一个更大的text encoder FLAN-UL2的encoder，光这部分的参数量就到了8.6B。unet的架构也提升到了3.0B。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20231211152627128.png" alt="image-20231211152627128"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20231211153134797.png" alt="image-20231211153134797"></p>
<p>作者通过大量实验得到以下两个 insight：</p>
<ul>
<li>在实践中，增加网络的深度，同时减少总的参数，可以在训练中获得更好的结果。</li>
<li>在初始阶段，在高分辨率下，仅使用卷积块来处理图像，同时更多的压缩表示送到transformer层，确保图像元素的全局交互。</li>
</ul>
<h4 id="5-3-4-RAPHAEL"><a href="#5-3-4-RAPHAEL" class="headerlink" title="5.3.4 RAPHAEL"></a>5.3.4 RAPHAEL</h4><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230704192147695.png" alt="image-20230704192147695"></p>
<p>作者观察到不同的文本概念在生成过程中影响不同的图像区域，而传统的交叉注意层通常很难在图像中充分保留这些不同的概念。为了缓解这个问题，我们采用了一个扩散模型，堆叠了数十个专家混合 (MoE) 层 ，包括空间 MoE 层和时间 MoE 层。具体来说，空间 MoE 层负责描绘特定图像区域中的不同概念，而时间 MoE 层则专注于在不同的扩散时间步长上绘制这些概念。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230704195433571.png" alt="image-20230704195433571"></p>
<p>另外，利用一个旁支的网络来根据注意力图预测输入图像的边缘图, 复杂的边界可以作为监督来指导模型保留各种风格的详细图像特征。</p>
<p>RAPHAEL的损失函数包含两部分：$L = L_{denoise}+L_{edge}$</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240130114154739.png" alt="image-20240130114154739"></p>
<h4 id="5-3-5-Muse"><a href="#5-3-5-Muse" class="headerlink" title="5.3.5 Muse"></a>5.3.5 Muse</h4><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230609181214290.png" alt="image-20230609181214290"></p>
<p>Muse是在离散 token 空间，通过 mask modeling 任务训练的：T5-XXL预训练的文本编码器生成文本embedding，用于 Base Transformer 和 SuperRes Transformer中，和 image token进行cross attention。Base model使用在低分辨率上256<em>256训练的VQGAN，并生成 16\</em>16的token，序列以每个样本的可变速率被mask，然后交叉熵损失学习预测mask的image token。一旦训练了 Base model，重建的较低分辨率token和 文本embedding  就被传递到超分辨率模型中，然后超分辨率模型学习以较高分辨率预测 masked tokens。</p>
<h4 id="5-3-5-PixArt-alpha"><a href="#5-3-5-PixArt-alpha" class="headerlink" title="5.3.5 PixArt-alpha"></a>5.3.5 PixArt-alpha</h4><p>目前 sota 的文生图模型需要大量的训练成本，训练数据。$pixart-\alpha$正如题目中提到的 fast training，主打<strong>低成本训练</strong>。采用了 meta 提出的 <strong>DiT</strong> 架构。模型参数只有<strong>0.6B</strong>，它的训练时长只有SD 1.5的10.8%，而且只使用了 <strong>25M</strong> 数据进行训练。</p>
<p>下面是和目前的主流模型的训练成本：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20231102171712747.png" alt="image-20231102171712747"></p>
<p>为了实现降低训练的计算成本同时保持图像的生成质量， pixart-alpha提出了三个关键设计。</p>
<ol>
<li><strong>training strategy decomposition</strong> </li>
</ol>
<p>将复杂的文本到图像的任务分解成三个简化的子任务：(1) 学习自然图像的像素分布，（2）学习文本图像对齐，（3）增强图像的美学质量。对于第一个子任务，使用低成本的类条件模型初始化 T2I 模型，从而显着降低学习成本。对于第二个和第三个子任务，制定了由预训练和微调组成的训练范式：对信息密度丰富的文本图像对数据进行预训练，然后对具有优越美学质量的数据进行微调，提高训练效率。</p>
<ol>
<li><strong>Efficient T2I Transformer</strong></li>
</ol>
<p>结合了交叉注意模块来注入文本条件并简化计算密集型类条件分支以提高效率。此外，我们引入了一种重新参数化技术，允许调整后的文本到图像模型直接加载原始类条件模型的参数。因此，我们可以利用从 ImageNet 中学到的有关自然图像分布的先验知识，为 T2I Transformer 提供合理的初始化并加速其训练。</p>
<ol>
<li><strong>High-information data</strong></li>
</ol>
<p>目前的文本图像对数据集如 Laion 其中文本标题经常缺乏信息内容，并且严重的长尾效应（及大量名词以极低的频率出</p>
<p>3现）。这些都影响模型的训练效率。pixart-alpha利用 LLaVA 在 SAM 数据集上生成 caption。</p>
<h4 id="5-3-6-PanGu-Draw"><a href="#5-3-6-PanGu-Draw" class="headerlink" title="5.3.6 PanGu-Draw"></a>5.3.6 PanGu-Draw</h4><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240130155824264.png" alt="image-20240130155824264"></p>
<p>如上图所示，目前文生图的大多采用多阶段训练策略来提高生成图片的质量和分辨率。PanGu-Draw 提出的时间解耦训练策略在资源效率方面超越了级联训练和分辨率提升训练。</p>
<p>作者从扩散过程的去噪轨迹中得到灵感，其中初始去噪阶段主要塑造图像的结构基础，而后期阶段则完善其纹理复杂性。基于以上事实，引入时间解耦训练策略，将综合文生图模型划分为在不同时间间隔上运行的专用子模型：结构生成器和纹理生成器，每个模型是原始模型的一半。每个子模型都是在不同的时间间隔下单独训练的。</p>
<p>模型结构方面采用 ==SDXL 的VAE模型，并基于其 Unet 模型的架构构建结构和纹理生成器==，为了实现双语文本到图像的生成（中文和英文），在中文训练数据集上预训练中文文本编码器 。然后，我们将来自中文文本编码器的文本嵌入与来自预训练的英文文本编码器的文本嵌入连接起来，作为去噪模型的最终文本嵌入。对于多分辨率图像生成，我们选择 1024x1024 左右的图像分辨率范围，并进一步根据与图像分辨率索引相对应的正弦位置嵌入来调节去噪模型。</p>
<p> <strong>promptenhancement</strong>：为了进一步提升生成质量，利用LLM将用户的简洁输入与模型所需的详细输入保持一致。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240130162205337.png" alt="image-20240130162205337"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240130162255805.png" alt="image-20240130162255805"></p>
<p>从结果来看，pangu 模型训练数据 caption 应该也是通过 LLM 处理过的，类似于 Dalle3 和 pixart-alpha提到的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2024/01/20/%E5%8F%AF%E6%8E%A7%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/20/%E5%8F%AF%E6%8E%A7%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">扩散模型可控生成的方法总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-20 21:00:00" itemprop="dateCreated datePublished" datetime="2024-01-20T21:00:00+08:00">2024-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-01 23:08:00" itemprop="dateModified" datetime="2024-02-01T23:08:00+08:00">2024-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">扩散模型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="扩散模型可控生成的方法总结"><a href="#扩散模型可控生成的方法总结" class="headerlink" title="扩散模型可控生成的方法总结"></a>扩散模型可控生成的方法总结</h1><p>文生图模型可控生成可以分为<strong>结构控制和内容控制</strong>。</p>
<p>结构控制以ControlNet和T2I-Adapter为代表，通过用户输入的 canny, sketch, depth map等来控制生成图像的结构，主要通过改变原始unet不同分辨率的中间特征来达到目的。controlnet是将额外网络的得到特征加到unet deocder上，T2I-Adapter是将额外网络得到的特征加到对应的Unet encoder上。</p>
<p>概念控制以 IP-Adapter为代表，通过引入新的输入来控制生成图像的内容。很多文章都验证了 <strong>cross attention layers</strong> 是控制图像空间布局与条件提示之间对应关系的关键，简言之，生成图像的语义主要通过cross attention来控制。<strong>prompt to prompt</strong>通过将原始prompt生成的 attention map和修改后的prompt生成的attention map结合到一起来达到图像编辑的功能。一些工作通过各种各样的方式得到新的特征，然后将其与文本特征连接或者是通过替换原始文本特征，将合并后的特征输入到扩散模型的UNet中，以指导图像生成，如photomaker。</p>
<p>接下来我们介绍一下可控生成的代表性工作Contronet，Adapter，后续很多的工作大多基于此做的改进来达到自己期望的结果。</p>
<h1 id="1、Controlnet"><a href="#1、Controlnet" class="headerlink" title="1、Controlnet"></a>1、Controlnet</h1><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>在 controlnet 之前的图像扩散模型，像 stable diffusion，只支持文本来控制图像生成。如果要生成符合期望，有特定细节的图像，需要调整 seed 和 prompt，耗时比较长。借助 ControlNet，可以使用各种输入条件如（outlines， human poses， depth mpas，edge maps等）控制图像生成。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240204114115794.png" alt="image-20240204114115794"></p>
<h3 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h3><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240204114212325.png" alt="image-20240204114212325"></p>
<p>ControlNet 是一种 “辅助式” 的神经网络模型结构，可以增强具有特定任务条件的预训练图像扩散模型。如 Figure 2 所示，Controlnet 可以应用于任意神经网络结构。Controlnet 主要在 <strong>trainable copy</strong> 上施加控制条件，然后将施加控制条件之后的结果和原来SD模型的结果相加获得最终的输出结果。</p>
<p>其中，原模型的权重保持不变，在训练中 frozen, <strong>保留了原模型原本的能力</strong>；与此同时，使用额外数据对 <strong>trainable copy</strong>进行微调，学习我们想要添加的条件。ContorlNet 模型中有两个 <strong>zero convolution</strong> 模块，它们是 $1\times1$卷积，并且权重和偏置都初始化为零。这样一来，在我们开始训练ControlNet之前，所有zero convolution模块的输出都为零，使得ControlNet完完全全就在原模型的能力上进行微调训练，不会产生大的能力偏差，<strong>也会降低破坏原模型能力的风险**</strong>。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/tmp.png" alt="tmp"></p>
<p>上面是应用在开源文生图模型 Stable Diffusion上 ControlNet 的整体结果，其主要在Stable Diffusion的U-Net中起作用，<strong>ControlNet主要将Stable Diffusion U-Net的Encoder部分进行复制训练，在Stable Diffusion U-Net的Decoder模块中通过skip connection加入了zero convolution模块处理后的特征</strong>，以实现对最终模型与训练数据的一致性。</p>
<p>具体地，ControlNet包含了12个编码块和1个Stable Diffusion U-Net中间块的“可训练”副本。这12个编码块有4种分辨率，分别是64×64、32×32、16×16和8×8，每种分辨率对应3个编码块 。ControlNet的输出被添加到Stable Diffusion U-Net的12 个残差结构和1个中间块中。同时由于Stable Diffusion U-Net是经典的U-Net结构，因此 ControlNet架构有很强的兼容性与迁移能力，可以用于其他扩散模型中。</p>
<p><strong>ControlNet一开始的输入Condition怎么与SD模型的隐空间特征结合呢？</strong>在这里ControlNet主要是训练过程中添加了四层卷积层，将图像空间Condition转化为隐空间Condition。这些卷积层的卷积核为4×4，步长为2，通道分别为16，32，64，128，初始化为高斯权重，并与整个ControlNet模型进行联合训练。</p>
<h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p><strong>优点</strong>：</p>
<ol>
<li>即插即用：controlnet不会影响SD模型原本的生成能力。</li>
<li>可控生成：controlnet在原本文本指导下，增加各种条件控制模型生成。</li>
<li>泛化能力强：可以和社区现有不同 finetune SD模型结合。</li>
<li>灵活：既适用于小规模数据训练（只连接 mid block），也适用于大规模数据训练（先训练contorlnet，再解锁冻结的sd 权重一起训练）。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>模型比较大（模型文件通常在一点几GB），增加了推理的时间。</li>
<li>当模型错误理解输入图像的语义时，模型很难生成正确的内容。</li>
</ol>
<h2 id="2、T2I-Adapter"><a href="#2、T2I-Adapter" class="headerlink" title="2、T2I-Adapter"></a>2、T2I-Adapter</h2><p>T2I-Adapter 和 ControlNet 模型一样，能够作为控制条件控制SD模型生成图片的过程。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240204192311798.png" alt="image-20240204192311798"></p>
<p>与 ControlNet 不同的是，T2I-Adapter通过一个 Adapter 额外模型去输入额外的条件，Adapter由四个特征提取模块和三个下采样模块组成，每个特征提取模块 scale由以及个卷积层和两个residual blocks组成。每个scale产生的特征维度与对应的unet层类似，然后和对应的Unet encoder 中间特征相加。</p>
<p><strong>优点</strong>:</p>
<ul>
<li><strong>即插即用</strong>：T2I-Adapter算法不会影响SD模型原本的生成能力。</li>
<li><strong>简单且小巧</strong>：它们可以轻松地与SD模型结合，T2I-Adapter模型大约只有77M的参数和大约300M的存储空间，且几乎不影响原本模型的推理速度。</li>
<li><strong>灵活组合</strong>：可以轻松与多个ControlNet模型组合使用，以实现多条件控制。</li>
<li><strong>泛化能力</strong>：在不同的SD模型上具备较好的泛化控制性能。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>生成质量相比ControlNet 略差。</li>
<li>预训练的模型相比ControlNet少。</li>
</ul>
<h2 id="3-IP-Adapter"><a href="#3-IP-Adapter" class="headerlink" title="3. IP-Adapter"></a>3. IP-Adapter</h2><p>Stable Diffusion系列模型在正常情况下是只支持文本提示词的输入，而IP-Adapter算法能够在SD模型的图像生成过程中引入<strong>图像提示词（Image Prompt）</strong>，从而能够识别输入图像的风格和内容，然后控制SD模型生成相似风格或者内容的图片，同时也可以搭配其他类型的ControlNet一起使用。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240204195928381.png" alt="image-20240204195928381"></p>
<p>IP-Adapter的关键设计是：<strong>解耦的交叉注意机制，它将文本特征和图像特征的交叉注意层分开。</strong>在这之前一些工作做法是 CLIP 图像编码器提取的图像特征通过可训练网络映射到新特征，然后与文本特征连接或者是通过替换原始文本特征，将合并后的特征输入到扩散模型的UNet中，以指导图像生成。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205111424762.png" alt="image-20240205111424762"></p>
<p>优点：</p>
<ul>
<li><strong>即插即用</strong>：IP-Adapter不会影响原本模型的能力。</li>
<li><strong>简单轻量</strong>：总训练参数约22M。</li>
<li><strong>灵活组合</strong>：可以与controlnet等结构控制的模型结合使用。</li>
<li><strong>泛化能力</strong>：在不同的SD模型上具备较好的泛化控制性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能生成内容和风格与参考图像相似的图像。</li>
</ul>
<h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h2><p>接下来我们介绍一些应用以上技术，在社区比较火的工作。</p>
<h3 id="4-1-AnyDoor"><a href="#4-1-AnyDoor" class="headerlink" title="4.1 AnyDoor"></a>4.1 AnyDoor</h3><p>AnyDoor的任务是 ViT-ALL 即 virtual try-all，zero-shot将任何参考图像放在任意场景图像的指定位置。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240202152533469.png" alt="image-20240202152533469"></p>
<p>模型架构如上，可以看做是 <strong>IP-Adapter和ControlNet</strong>的结合，这里的通过一个自监督的图像编码器提取图像特征然后替代文本特征输入到Cross attention中。Detail Extractor是一个Controlnet网络结构。训练时候，只冻结U-net encoder，</p>
<p><strong>关键创新点</strong>：<font color=blue>利用一个自监督的图像表示模型-DINO-V2来提取更加细粒度的图像特征，而不是CLIP</font></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205143940328.png" alt="image-20240205143940328"></p>
<h3 id="4-2-PhotoMaker"><a href="#4-2-PhotoMaker" class="headerlink" title="4.2 PhotoMaker"></a>4.2 PhotoMaker</h3><p>photomaker的任务是identity-preserving image synthesis，即生成ID一致的人物图像。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205153137031.png" alt="image-20240205153137031"></p>
<p>模型结构如上图所示，通过将image encoder提取到 image embedding 与 text embedding融合再替换text embedding中的对应的token，来达到引入 ID 图像信息。训练的时候，原本Unet是一起训练的，无法做到即插即用。效果看起来跟IP-adapter接近，输入的参考图像的数量越多生成效果越好。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205153851008.png" alt="image-20240205153851008"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205153925988.png" alt="image-20240205153925988"></p>
<h3 id="4-3-InstantID"><a href="#4-3-InstantID" class="headerlink" title="4.3 InstantID"></a>4.3 InstantID</h3><p>InstantID的任务是 identity-preserving image synthesis，即生成ID一致的人物图像。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205144907436.png" alt="image-20240205144907436"></p>
<p>模型结构如上图，也可以看作是 IP-Adapter 和 ControlNet的结合。其中，IP-Adapter的输入是通过 Face Encoder 模型来提取脸部特征。ControlNet的输入是面部关键点图，条件输入去除了文本特征，只使用 Face embedding。训练的时候，Unet完全冻结。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240205153944668.png" alt="image-20240205153944668"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2024/01/02/ECLIPSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/02/ECLIPSE/" class="post-title-link" itemprop="url">ECLIPSE——A Resource-Efficient Text-to-Image Prior for Image Generations</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-01-02 21:00:00 / Modified: 23:08:00" itemprop="dateCreated datePublished" datetime="2024-01-02T21:00:00+08:00">2024-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">扩散模型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ECLIPSE-A-Resource-Efficient-Text-to-Image-Prior-for-Image-Generations"><a href="#ECLIPSE-A-Resource-Efficient-Text-to-Image-Prior-for-Image-Generations" class="headerlink" title="ECLIPSE: A Resource-Efficient Text-to-Image Prior for Image Generations"></a>ECLIPSE: A Resource-Efficient Text-to-Image Prior for Image Generations</h1><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240104202314415.png" alt="image-20240104202314415"></p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>目前 unCLIP 类型的文生图模型，如 DALLE2，kandinsky2.2， Karlo，<font color=red>先验模型参数太大，对计算资源和训练数据的要求比较高</font>。论文利用对比学习的方法，来训练先验模型，仅使用 3.3%参数和2.8%的数据进行训练就能超过baseline的先验模型，且可以和预训练的扩散图像解码器搭配使用。</p>
<p><strong>现有 diffusion prior model 的问题</strong></p>
<p>论文通过实验说明 prior model steps的增加并不能提高最终生成图片的质量。因此扩散的训练方式存在很多不必要的计算。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105191501550.png" alt="image-20240105191501550"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105191509560.png" alt="image-20240105191509560"></p>
<p>图a是</p>
<h2 id="2、方法"><a href="#2、方法" class="headerlink" title="2、方法"></a>2、方法</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105115308506.png" alt="image-20240105115308506"></p>
<p>论文采用非扩散的训练方式，目标函数有两个，第一个目标函数如下：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105193153414.png" alt="image-20240105193153414"></p>
<p>将文本embedding投影到视觉embedding上，通过以上近似扩散先验模型的目标函数来实现。这里没有 CFG。但这种相当于直接学习一个函数将文本embedding映射成视觉embedding，泛化性可能比较差。</p>
<p>第二个目标函数如下：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105194510830.png" alt="image-20240105194510830"></p>
<p>利用对比损失来对齐图像和文本。</p>
<p>最终的损失函数为：<img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105194826376.png" alt="image-20240105194826376">$\lambda$ 设置为 0.2</p>
<h2 id="3、实验"><a href="#3、实验" class="headerlink" title="3、实验"></a>3、实验</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105195206469.png" alt="image-20240105195206469"></p>
<p>可以看到 eclipse的方式大大减少了使用的数据量和模型的参数。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105195231282.png" alt="image-20240105195231282"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240105195311653.png" alt="image-20240105195311653"></p>
<p>对比损失对于图像和文本之间的对齐是有帮助的。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>unclip的模型结构，decoder的训练直接通过一个image encoder来编码图像得到image embedding，先验模型的任务理论上就是学习一个模型来对齐文本和图像之间的embedding，对齐的越好，那么对于decoder生成越有帮助。并非只能通过扩散的方式来学习先验模型。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/12/30/%E6%96%87%E7%94%9F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/30/%E6%96%87%E7%94%9F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B/" class="post-title-link" itemprop="url">文生图模型演进</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-30 21:00:00" itemprop="dateCreated datePublished" datetime="2023-12-30T21:00:00+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-20 23:08:00" itemprop="dateModified" datetime="2024-01-20T23:08:00+08:00">2024-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">扩散模型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>此文是为了更好的理解 stable diffusion以及DALL-E 3等最新的图像生成模型，回顾一下在它们之前更早的模型。stable diffusion的作者也是 VQ-GAN的作者，DALL-E3之前还有 DALL-E，DALL-E2。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/640.png" alt="图片"></p>
<h2 id="2-AE"><a href="#2-AE" class="headerlink" title="2. AE"></a>2. AE</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/v2-120f54237d6bc3529d54270139ea8276_r.jpg" alt="img"></p>
<p><strong>作用</strong>：可以用于学习<font color=red> 无标签数据的有效编码</font>, 学习对高维数据的进行低维表示，常用于<font color=red>降维</font>，数据去噪，特征学习。</p>
<p><strong>基本思想</strong>：AE（auto-encoder）是很早之前的技术了，思路也非常简单：用一个编码器（Encoder）把输入编码为 latent vector；然后用 Decoder 将其解码为重建图像，<font color=red>希望重建后的图像与输入图像越接近越好</font>。通常 latent vector 的维度比输入、输出的维度小，因此称之为 bottleneck。AE 是一个自重建的过程，所以叫做“自-编码器”。</p>
<p><strong>特点</strong>：但是模型在 Latent Space 没有增加任何的约束或者正则化，意味着<font color=red>不知道 Latent Space 是如何构建的</font>, 所以很难使用 latent space 来采样生成一个新的图像。</p>
<h2 id="DAE"><a href="#DAE" class="headerlink" title="DAE"></a>DAE</h2><p>DAE（Denoising autoencoder）将原始输入图像进行一定程度的打乱，得到 corrupted input。然后把后者输入AE，目标仍然是希望重建后的图像与原始输入越接近越好。DAE 的效果很不错，原因之一就是图像的冗余度太高了，即使添加了噪声，模型依然能抓取它的特征。而这种方式增强了模型的鲁棒性，防止过拟合。</p>
<h2 id="3-VAE"><a href="#3-VAE" class="headerlink" title="3. VAE"></a>3. VAE</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/v2-9fdb71e7e0b359f900a54878be5f2477_r.jpg" alt="img"></p>
<p><strong>论文</strong>：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1312.6114">[1312.6114] Auto-Encoding Variational Bayes</a></p>
<p><strong>作用</strong>：除了AE的作用之外，还广泛应用于生成新的、与训练数据相似但不完全相同的样本。</p>
<p><strong>基本思想</strong>：VAE（Variational autoencoder）仍然由一个编码器和一个解码器构成，并且目标仍然是重建原始输入。但中间不再是学习 latent vector z ，而是学习它的后验分布 $p(z|x)$ ，并假设它遵循<font color=red>多维高斯分布</font>。具体来说，编码器得到两个输出，并分别作为高斯分布的均值和协方差矩阵的对角元（假设协方差矩阵是对角矩阵）。然后在这个高斯分布中采样，送入解码器。实际工程实现中，会用到重参数化（reparameterization）的技巧。</p>
<p><strong>特点</strong>：VAE训练目标除了重构误差，还包括最小化隐空间的KL散度，以确保隐空间与标准正态分布接近。但VAE最大的问题也是这个，使用了固定的先验分布。</p>
<h2 id="4-VQ-VAE"><a href="#4-VQ-VAE" class="headerlink" title="4. VQ-VAE"></a>4. VQ-VAE</h2><blockquote>
<p><strong>VQ(vector quantization)</strong>是一种数据压缩和量化的技术，它可以将连续的向量映射到一组离散的具有代表性的向量中。在深度学习领域，VQ通常用来将连续的隐空间表示映射到一个有限的、离散的 <strong>codebook</strong> 中。</p>
</blockquote>
<p>VAE 具有一个最大的问题就是使用了固定的先验（高斯分布），其次是使用了<strong>连续的中间表征，导致模型的可控性差</strong>。为了解决这个问题，VQ-VAE（Vector Quantized Variational Autoencoder）选择使用<strong>离散的中间表征</strong>，同时，通常会使用一个自回归模型来学习先验（例如 PixelCNN），在训练完成后，用来采样得到 $z_e$。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/v2-956ed05aed4340fd44c2a2853800edf0_r.jpg" alt="img"></p>
<p>图像首先经过encoder，得到$z_e$,它是$H\times W$个 $D$ 维向量。$e_1,e_2,…,e_k$是 $K$ 个 $D$ 维向量，称为codebook。 对于 $z_e$ 中的每个 $D$ 维向量，都可以在 codebook 中找到最接近的 $e_i$, 构成 $z_q$, 这就是decoder的输入。一般 $k=8192, D=512 or 768$。</p>
<p>从 $z_e(x)$ 到 $z_q(x)$ 这个变化可以看成一个聚类，$e_1,e_2,…,e_k$ 可以看作 K 个聚类中心。这样把 encoder 得到的 embedding 离散化了，只由聚类中心表示。</p>
<h3 id="4-1-VQ-VAE的训练"><a href="#4-1-VQ-VAE的训练" class="headerlink" title="4.1 VQ-VAE的训练"></a>4.1 VQ-VAE的训练</h3><p>在VQ中使用 Argmin来获取最小的距离，这一步是不可导的，因为无法将 Decoder 和 Encoder联合训练，针对这个问题，作者添加了一个trick，如上图红线所示：直接将 $z_q(x)$的梯度cooy给$Z_e(x)$, 而不是给 codebook里面的embedding。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E6%8E%A8%E6%88%AA%E5%9B%BE_20240112000325.jpg" alt="推推截图_20240112000325"></p>
<p>VQ-VAE的loss如上所示，分成三部分，第一项用来训练 encoder和decoder，第二项叫 codebook loss,只训练 codebook，让codebook中的embedding向各自最近的$Z_e(x)$靠近VQGAN。第三项叫 commitment loss,只训练encoder, 目的是encourage the output of encoder to stay close to the chosen codebook vector to prevent it from flucturating too frequently from one code vector to another, 即防止encoder的输出频繁在各个codebook embedding之间跳</p>
<p>具体代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VectorQuantizer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_embeddings, embedding_dim, commitment_cost</span>):</span><br><span class="line">        <span class="built_in">super</span>(VectorQuantizer, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self._embedding_dim = embedding_dim</span><br><span class="line">        self._num_embeddings = num_embeddings</span><br><span class="line">        </span><br><span class="line">        self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim)</span><br><span class="line">        self._embedding.weight.data.uniform_(-<span class="number">1</span>/self._num_embeddings, <span class="number">1</span>/self._num_embeddings)</span><br><span class="line">        self._commitment_cost = commitment_cost</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment"># convert inputs from BCHW -&gt; BHWC</span></span><br><span class="line">        inputs = inputs.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).contiguous()</span><br><span class="line">        input_shape = inputs.shape</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Flatten input</span></span><br><span class="line">        flat_input = inputs.view(-<span class="number">1</span>, self._embedding_dim)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate distances</span></span><br><span class="line">        distances = (torch.<span class="built_in">sum</span>(flat_input**<span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) </span><br><span class="line">                    + torch.<span class="built_in">sum</span>(self._embedding.weight**<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">                    - <span class="number">2</span> * torch.matmul(flat_input, self._embedding.weight.t()))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Encoding</span></span><br><span class="line">        encoding_indices = torch.argmin(distances, dim=<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        encodings = torch.zeros(encoding_indices.shape[<span class="number">0</span>], self._num_embeddings, device=inputs.device)</span><br><span class="line">        encodings.scatter_(<span class="number">1</span>, encoding_indices, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Quantize and unflatten</span></span><br><span class="line">        quantized = torch.matmul(encodings, self._embedding.weight).view(input_shape)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Loss</span></span><br><span class="line">        e_latent_loss = F.mse_loss(quantized.detach(), inputs)</span><br><span class="line">        q_latent_loss = F.mse_loss(quantized, inputs.detach())</span><br><span class="line">        loss = q_latent_loss + self._commitment_cost * e_latent_loss</span><br><span class="line">        </span><br><span class="line">        quantized = inputs + (quantized - inputs).detach()</span><br><span class="line">        avg_probs = torch.mean(encodings, dim=<span class="number">0</span>)</span><br><span class="line">        perplexity = torch.exp(-torch.<span class="built_in">sum</span>(avg_probs * torch.log(avg_probs + <span class="number">1e-10</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># convert quantized from BHWC -&gt; BCHW</span></span><br><span class="line">        <span class="keyword">return</span> loss, quantized.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>).contiguous(), perplexity, encodings</span><br></pre></td></tr></table></figure>
<h3 id="4-2-VQ-VAE-PixelCNN"><a href="#4-2-VQ-VAE-PixelCNN" class="headerlink" title="4.2 VQ-VAE + PixelCNN"></a>4.2 VQ-VAE + PixelCNN</h3><p>有了上述的 VQ-VAE 模型，可以很容易实现图像<strong>压缩、重建</strong>的目的，但是无法生成新的图像数据。当然可以随机生成 Index，然后对应生成量化后的 latent code，进而使用 Decoder 来生成输出图像。但是这样的 latent code 完全没有全局信息甚至局部信息，因为每个位置都是随机生成的。因此，作者引入了 PixelCNN 来自回归的生成考虑了全局信息的 latent code，进而可以生成更真实的图像，如下图所示：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240112001504547.png" alt="image-20240112001504547"></p>
<p>PixelCNN 和 VQ-VAE 的一作是同一个人，来自 Google DeepMind，对应的论文为：Conditional Image Generation with PixelCNN Decoders。此处我们不再对 PixelCNN 展开，只需要知道它是一个自回归生成模型，可以逐个像素的生成，因为其是自回归模型，所以每个位置都能看到之前位置的信息，这样生成的 latent code 能够更全面的考虑到空间信息，有助于提高模型生成图像的质量和多样性。</p>
<h3 id="4-3-VQ-VAE-2"><a href="#4-3-VQ-VAE-2" class="headerlink" title="4.3 VQ-VAE-2"></a>4.3 VQ-VAE-2</h3><p>VQ-VAE-2 的模型结构如下图所示，以 256x256 的图像压缩重建为例：</p>
<ul>
<li>训练阶段：其首先使用 Encoder 将图像压缩到 Bottom Level，对应大小为 64x64，然后进一步使用 Encoder 压缩到 Top Level，大小为 32x32。重建时，首先将 32x32 的表征经过 VQ 量化为 latent code，然后经过 Decoder 重建 64x64 的压缩图像，再经过 VQ 和 Decoder 重建 256x256 的图像。</li>
<li>推理阶段（图像生成）：使用 PixelCNN 首先生成 Top Level 的离散 latent code，然后作为条件输入 PixelCNN 以生成 Bottom Level 的更高分辨率的离散 latent code。之后使用两个 Level 的离散 latent code 生成最终的图像。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/640-20240112002031130.png" alt="图片"></p>
<p>当然，基于这个思想作者也进一步验证了使用 3 个 Level 来生成 1024x1024 分辨率的图像，相应的压缩分辨率分别为 128x128、64x64、32x32。</p>
<h2 id="5-VQ-GAN"><a href="#5-VQ-GAN" class="headerlink" title="5 VQ-GAN"></a>5 VQ-GAN</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>paper:<a target="_blank" rel="noopener" href="https://openaccess.thecvf.com/content/CVPR2021/html/Esser_Taming_Transformers_for_High-Resolution_Image_Synthesis_CVPR_2021_paper.html">https://openaccess.thecvf.com/content/CVPR2021/html/Esser_Taming_Transformers_for_High-Resolution_Image_Synthesis_CVPR_2021_paper.html</a></p>
<p>code:<a target="_blank" rel="noopener" href="https://github.com/CompVis/taming-transformers">https://github.com/CompVis/taming-transformers</a></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230512112944268.png" alt="image-20230512112944268"></p>
<p>VQ-GAN 相比较 VQ-VAE 的主要改变有以下几点：</p>
<ul>
<li>引入 GAN 的思想，将 VQ-VAE 当做生成器（Generator），并加入判别器（Discriminator），以对生成图像的质量进行判断、监督，以及加入感知重建损失（不只是约束像素的差异，还约束 feature map 的差异），以此来重建更具有保真度的图片，也就学习了更丰富的 codebook。</li>
<li>将 PixelCNN 替换为性能更强大的自回归 GPT2 模型（针对不同的任务可以选择不同的规格）</li>
<li>引入滑动窗口自注意力机制，以降低计算负载，生成更大分辨率的图像。</li>
</ul>
<p>VQ-GAN 也是 stable diffusion的作者。</p>
<h3 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h3><p>模型结构如上图所示，实际训练的时候是分为<font color=red>两阶段训练的</font>。</p>
<p>如下图所示，第一阶段训练，相比 VQ-VAE 主要是增加 Discriminator， 以及将重建损失替换成 <font color=red> LPIPS损失：</font></p>
<ul>
<li>Discriminator：对生成的图像块进行判别，每一块都会返回 True 和 False，然后将对应的损失加入整体损失中。</li>
<li>LPIPS：除了像素级误差外，也会使用 VGG 提取 input 图像和 reconstruction 图像的多尺度 feature map，以监督对应的误差（具体可参考 lpips.py - CompVis/taming-transformers · GitHub）。</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240113215830827.png" alt="image-20240113215830827"></p>
<h2 id="6-DALL-E-dVAE-DALL-E"><a href="#6-DALL-E-dVAE-DALL-E" class="headerlink" title="6. DALL-E (dVAE, DALL-E)"></a>6. DALL-E (dVAE, DALL-E)</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>DALL-E 最主要的贡献是提供了不错的文本引导图片生成的能力，其不是在 VQ-VAE 基础上修改，而是首先引入 VAE 的变种 dVAE，然后在此基础上进一步训练 DALL-E。可惜的是，OpenAI 并不 Open，只开源了 dVAE 部分模型，文本引导生成部分并没有开源，不过 Huggingface 和 Google Cloud 团队进行了复现，并发布对应的 DALL-E mini 模型。</p>
<p>DALL-E 对应的论文为：[2102.12092] Zero-Shot Text-to-Image Generation。对应的代码库为：GitHub - openai/DALL-E: PyTorch package for the discrete VAE used for DALL·E.。</p>
<p>DALL-E mini 对应的文档为：DALL-E Mini Explained，对应的代码库为：GitHub - borisdayma/dalle-mini: DALL·E Mini - Generate images from a text prompt。</p>
<h3 id="6-2-dVAE"><a href="#6-2-dVAE" class="headerlink" title="6.2 dVAE"></a>6.2 dVAE</h3><p>dVAE（discrete VAE）与VQ-VAE的区别在于<font color=red>引入 Gumbel Softmax 来训练</font>, 避免 VQ-VAE 训练中 ArgMin 不可导的问题。 </p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240113222402539.png" alt="image-20240113222402539"></p>
<h3 id="6-3-模型训练"><a href="#6-3-模型训练" class="headerlink" title="6.3 模型训练"></a>6.3 模型训练</h3><p>有了 dVAE 模型之后，第二阶段就是就是训练 Transformer（此阶段会固定 dVAE），使其具备文本引导生成的能力。DALL-E 使用大规模的图像-文本对数据集进行训练，训练过程中使用 dVAE 的 Encoder 将图像编码为离散的 latent code。然后将文本输入 Transformer，并使用生成的 latent code 来作为 target 输出。以此就可以完成有监督的自回归训练。推理时只需输入文本，然后逐个生成图像对应的 Token，直到生成 1024 个，然后将其作为离散的 latent code 进一步生成最终图像。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240113222517785.png" alt="image-20240113222517785"></p>
<p>最终作者在 1024 个 16G 的 V100 GPU 上完成训练，batch size 为 1024，总共更新了 430,000 次模型，也就相当于训练了 4.3 亿图像-文本对（训练集包含 250M 图像-文本对，主要是 Conceptual Captions 和 YFFCC100M）。</p>
<h3 id="6-4-DALL-E-mini-模型概述"><a href="#6-4-DALL-E-mini-模型概述" class="headerlink" title="6.4 DALL-E mini 模型概述"></a>6.4 DALL-E mini 模型概述</h3><p>如下图所示，DALL-E mini 中作者使用 VQ-GAN 替代 dVAE，使用 Encoder + Decoder 的 BART 替代 DALL-E 中 Decoder only 的 Transformer。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240113222725076.png" alt="dalle-e mini infer"></p>
<p>在推理过程中，不是生成单一的图像，而是会经过采样机制生成多个 latent code，并使用 VQ-GAN 的 Decoder 生成多个候选图像，之后再使用 CLIP 提取这些图像的 embedding 和文本 embedding，之后进行比对排序，挑选出最匹配的生成结果。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240113222818173.png" alt="image-20240113222818173"></p>
<h3 id="6-5-DALL-E-mini-和-DALL-E-对比"><a href="#6-5-DALL-E-mini-和-DALL-E-对比" class="headerlink" title="6.5 DALL-E mini 和 DALL-E 对比"></a>6.5 DALL-E mini 和 DALL-E 对比</h3><p>DALL-E mini 和 DALL-E 在模型、训练上都有比较大的差异，具体体现在：</p>
<ul>
<li>DALL-E 使用 12B 的 GPT-3 作为 Transformer，而 mini 使用的是 0.4B 的 BART，小 27 倍。</li>
<li>mini 中使用预训练的 VQ-GAN、BART 的 Encoder 以及 CLIP，而 DALL-E 从头开始训练，mini 训练代价更小。</li>
<li>DALL-E 使用 1024 个图像 Token，词表更小为 8192，而 mini 使用 256 个图像 Token，词表大小为 16384。</li>
<li>DALL-E 支持最多 256 个文本 Token，对应词表为 16,384，mini 支持最多 1024 文本 Token，词表大小为 50,264。</li>
<li>mini 使用的 BART 是 Encoder + Decoder 的，因此文本是使用双向编码，也就是每个文本 Token 都能看到所有文本 Token，而 DALL-E 是 Decoder only 的 GPT-3，文本 Token 只能看到之前的 Token。</li>
<li>DALL-E 使用 250M 图像-文本对训练，而 mini 只使用了 15M。</li>
</ul>
<h2 id="7-CLIP-VQ-GAN-VQGAN-CLIP"><a href="#7-CLIP-VQ-GAN-VQGAN-CLIP" class="headerlink" title="7 CLIP+VQ-GAN(VQGAN-CLIP)"></a>7 CLIP+VQ-GAN(VQGAN-CLIP)</h2><p>Katherine 等人将 VQ-GAN 和 OpenAI 发布的 CLIP 模型结合起来，利用 CLIP 的图文对齐能力来赋予 VQ-GAN 文本引导生成的能力。其最大的优势是不需要额外的预训练，也不需要对 CLIP 和 VQ-GAN 进行微调，只需在推理阶段执行少量的迭代即可实现。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240113223222191.png" alt="image-20240113223222191"></p>
<p>如上图所示：使用初始图像通过 VQ-GAN 生成一个图像，然后使用 CLIP 对生成图像和 Target Text 提取 embedding，然后计算相似性，并将其误差作为反馈对隐空间的 Z-vector 进行迭代更新，直到生成图像和 Target Text 对应的 embedding 很相似为止。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1312.6114">https://arxiv.org/abs/1312.6114</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1711.00937">https://arxiv.org/abs/1711.00937</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1606.05328">https://arxiv.org/abs/1606.05328</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1906.00446">https://arxiv.org/abs/1906.00446</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2012.09841">https://arxiv.org/abs/2012.09841</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/CompVis/taming-transformers">https://github.com/CompVis/taming-transformers</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2102.12092">https://arxiv.org/abs/2102.12092</a></li>
<li><a target="_blank" rel="noopener" href="https://wandb.ai/dalle-mini/dalle-mini/reports/DALL-E-Mini-Explained--Vmlldzo4NjIxODA">https://wandb.ai/dalle-mini/dalle-mini/reports/DALL-E-Mini-Explained--Vmlldzo4NjIxODA</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/borisdayma/dalle-mini">https://github.com/borisdayma/dalle-mini</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2204.08583">https://arxiv.org/abs/2204.08583</a></li>
<li><a target="_blank" rel="noopener" href="https://python.plainenglish.io/variational-autoencoder-1eb543f5f055">https://python.plainenglish.io/variational-autoencoder-1eb543f5f055</a></li>
<li><a target="_blank" rel="noopener" href="https://ljvmiranda921.github.io/notebook/2021/08/08/clip-vqgan/">https://ljvmiranda921.github.io/notebook/2021/08/08/clip-vqgan/</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/12/10/Personalization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/10/Personalization/" class="post-title-link" itemprop="url">Lates Personnalization Overview</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-10 21:00:00" itemprop="dateCreated datePublished" datetime="2023-12-10T21:00:00+08:00">2023-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-10 23:08:00" itemprop="dateModified" datetime="2022-12-10T23:08:00+08:00">2022-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">扩散模型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Latest-Personnalization-Overview"><a href="#Latest-Personnalization-Overview" class="headerlink" title="Latest Personnalization Overview"></a>Latest Personnalization Overview</h1><h2 id="ZipLoRA"><a href="#ZipLoRA" class="headerlink" title="ZipLoRA"></a>ZipLoRA</h2><blockquote>
<p>time: 2023.11</p>
<p>source: google</p>
<p>title: ZipLoRA: any subject in any style by Effectively merging loras</p>
</blockquote>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/%E6%88%AA%E5%9B%BE20231205114657.png" alt="截图20231205114657"></p>
<p>ziplora主要基于一些事实的观察：</p>
<ol>
<li>不通过sd1.x， sdxl能够仅通过一张图片就能学习到图片的风格；</li>
<li>lora 权重是稀疏的，大多数值都很小，对生成质量和逼真度影响很小；</li>
<li>两个独立训练的 LoRA 的权重矩阵的列彼此之间可能具有不同程度的“对齐”，例如通过余弦相似度来测量。 我们发现直接对具有高余弦相似度的列求和会降低合并模型的性能；</li>
</ol>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20231205150545862.png" alt="image-20231205150545862"></p>
<p>ziplora通过优化以下的损失：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20231205151130045.png" alt="image-20231205151130045"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20231205150554367.png" alt="image-20231205150554367"></p>
<p>前两项是，最小化合并后的lora与内容lora、风格lora之间的差异，来保留合并后的lora生成参考风格和内容能力；</p>
<p>最后一项是，最小化内容和风格lora之间的余弦相似度；</p>
<p>训练的时候，只优化 合并系数 <script type="math/tex">m_c,m_s</script>, 文章只需要100次参数更新就能达到很好的效果。</p>
<h2 id="AnyText"><a href="#AnyText" class="headerlink" title="AnyText"></a>AnyText</h2><blockquote>
<p>time: 2023.12</p>
<p>source: alibaba</p>
<p>title：ANYTEXT: MULTILINGUAL VISUAL TEXT GENERATION AND EDITING</p>
<p>code：<a target="_blank" rel="noopener" href="https://github.com/tyxsspa/AnyText">https://github.com/tyxsspa/AnyText</a></p>
<p>paper：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2311.03054">https://arxiv.org/abs/2311.03054</a></p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>作者介绍了一下现有开源文生图模型生成特定文字效果比较差及其原因，主要由以下三点：</p>
<ol>
<li>模型的训练数据集，如 LAION-5B 缺乏文本内容的手动注释或者OCR结果。</li>
<li>开源的模型使用的文本编码器采用基于词汇的分词器，无法直接访问字符。</li>
<li>大多数扩散模型的loss中缺乏对文本区域的专门监督。</li>
</ol>
<p>作者提出的 AnyText 框架，在 text-control diffusion pipeline的基础上，增加了两个组件：辅助潜在模块将文本字形、位置和遮罩图像等辅助信息编码到潜在空间中以辅助文本生成和编辑；文本嵌入模块采用 OCR 模型将笔画信息编码为嵌入，然后与来自分词器的图像caption embedding 融合，以呈现与背景无缝混合的文本；最后，引入图像空间中的文本感知损失以进一步提高书写准确性。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116113204422.png" alt="image-20240116113204422"></p>
<p>模型的loss包含两个部分：<img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116113426377.png" alt="image-20240116113426377"></p>
<p>第一部分损失如下：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116113559130.png" alt="image-20240116113559130"></p>
<p>第二部分损失是 text perceptual loss，利用 文字的位置条件 $lp$，准确定位到生成文本的区域，利用 PP-OCRv3 模型通过裁剪、仿射变换、填充和归一化等操作对位置 $l_p$ 处的原始图像$x_0$ 和 去噪重建后图像 $x^\prime_0$ 进行处理, 利用全连接层之前的特征图 $\hat{m}_p$ 和 $\hat{m}_{p}^\prime$分别表示原始图像和预测图像中位置 p 处的文本书写信息。文本感知损失表示为</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116115109747.png" alt="image-20240116115109747"></p>
<p>Auxiliary latent module 利用三种类型的辅助条件来产生 latent feature amp $z_a$ 分别是，字形 $l_g$，位置 $l_p$，masked image $l_m$。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116114237703.png" alt="image-20240116114237703"></p>
<p>$f$ 是一个卷积的fusion layer。$z_a$ 的  channels 数量和 $z_t$ 一致。</p>
<p>Text embedding module 将字形线渲染到图像中，利用预先训练的视觉模型，PP-OCRv3 的识别模型对字形信息进行编码，并从caption标记中替换它们的嵌入，然后一起送到 基于 Transformer 的文本编码器中。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>论文开源了一个数据集用于文本生成 AnyWord-3M</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116141058257.png" alt="image-20240116141058257"></p>
<p>可以看到 OCR 的信息对于效果提升是最大的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/08/19/Stable%20DIffusion%20%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/19/Stable%20DIffusion%20%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B/" class="post-title-link" itemprop="url">Stable Diffusion 系列模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-19 21:00:00" itemprop="dateCreated datePublished" datetime="2023-08-19T21:00:00+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-19 23:08:00" itemprop="dateModified" datetime="2023-12-19T23:08:00+08:00">2023-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">扩散模型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Stable-Diffusion-系列模型"><a href="#Stable-Diffusion-系列模型" class="headerlink" title="Stable Diffusion 系列模型"></a>Stable Diffusion 系列模型</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116234259305.png" alt="image-20240116234259305"></p>
<p>stable diffusion系列从 LDM 到SDXL 一直是开源工作里传播和使用最广的，大量工作都在此基础上展开。</p>
<p>从 2021年5月 openai 发表的 DM beat GANS 开始，diffusion model 的效果开始超过传统的 GAN 模型，进一步推动了 DM 在图像生成领域的应用。</p>
<p>早期的 DM 作用于像素空间，训练和推理的成本很高，为了实现在有效的计算资源上训练 DM，同时保持其质量和灵活性，作者提出将 DM 应用于强大的预训练 AutoEncoder 的隐空间（Latent Space），这也就是为什么提出的模型叫 <strong>LDM</strong>。此外，作者还在模型中引入交叉注意力层，可以将文本、边界框等条件很方便地引入到模型中，将 DM 转化为强大而灵活的生成器，实现高分辨率的生成。作者提出的 LDM 模型同样在图像修复、类别条件生成等方面取得很好的效果，同时与基于像素空间的扩散模型相比，大大降低计算要求。</p>
<h2 id="2-演进"><a href="#2-演进" class="headerlink" title="2. 演进"></a>2. 演进</h2><h3 id="2-1-Latent-Diffusion"><a href="#2-1-Latent-Diffusion" class="headerlink" title="2.1 Latent Diffusion"></a>2.1 Latent Diffusion</h3><p>Stable Diffusion 之前的版本，对应的正是论文的开源版本，位于代码库 High-Resolution Image Synthesis with Latent Diffusion Models 中。</p>
<p>该版本发布于 2022 年 4 月，主要包含三个模型：</p>
<ul>
<li>文生图模型：基于 LAION-400M 数据集训练，包含 1.45B 参数。</li>
<li>图像修复模型：指定区域进行擦除。</li>
<li>基于 ImageNet 的类别生成模型：在 ImageNet 上训练，指定类别条件生成，获得了 3.6 的 FID 分数。使用了 Classifier Free Guidance 技术。</li>
</ul>
<p>代码实现参考了 OpenAI 的 Diffusion Models Beat GANs 代码实现。</p>
<h3 id="2-2-stable-diffusion-V1"><a href="#2-2-stable-diffusion-V1" class="headerlink" title="2.2 stable diffusion V1"></a>2.2 stable diffusion V1</h3><p>V1 系列的模型结构和LDM类似基本没有变化；</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/v2-3123494fa758b5fc404f42752e2f1101_r.jpg" alt="img"></p>
<p>该版本发布于 2022 年 8 月，该模型包含 2 个子模型：</p>
<ul>
<li>AutoEncoder 模型：U-Net，8 倍下采样，包含 860M 参数。</li>
<li>Text Encoder 模型：使用 CLIP ViT-L/14 中的 Text encoder。</li>
</ul>
<p>模型首先在 256x256 的分辨率下训练，然后在 512x512 的分辨率下微调。总共包含 4 个子版本：</p>
<ul>
<li>sd-v1-1.ckpt：<ul>
<li>在 LAION-2B-en 数据集上以 256x256 分辨率训练 237k step。</li>
<li>在 LAION-high-resolution（LAION-5B 中超过 1024x1024 分辨率的 170M 样本）上以 512x512 分辨率继续训练 194k step。</li>
</ul>
</li>
<li>sd-v1-2.ckpt：<ul>
<li>复用 sd-v1-1.ckpt，在 LAION-aesthetics v2 5+（LAION-2B-en 中美观度分数大于 5.0 的子集） 上以 512x512 分辨率继续训练 515k step。</li>
</ul>
</li>
<li>sd-v1-3.ckpt：<ul>
<li>复用 sd-v1-2.ckpt，在 LAION-aesthetics v2 5+ 上以 512x512 分辨率继续训练 195k step，使用了 Classifier Free Guidance 技术，以 10% 概率删除文本条件。</li>
</ul>
</li>
<li>sd-v1-4.ckpt：<ul>
<li>复用 sd-v1-2.ckpt，在 LAION-aesthetics v2 5+ 上以 512x512 分辨率继续训练 225k step，使用了 Classifier Free Guidance 技术，以 10% 概率删除文本条件。</li>
</ul>
</li>
</ul>
<p>对应的 FID 和 CLIP 分数如下图所示：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20240116235722441.png" alt="image-20240116235722441"></p>
<h3 id="2-3-Stable-Diffusion-V1-5"><a href="#2-3-Stable-Diffusion-V1-5" class="headerlink" title="2.3 Stable Diffusion V1.5"></a>2.3 Stable Diffusion V1.5</h3><p>Stable Diffusion 的 V1.5 版本，由runway发布，</p>
<p>该版本发布于 2022 年 10 月，主要包含两个模型：</p>
<ul>
<li>sd-v1-5.ckpt：<ul>
<li>复用 sd-v1-2.ckpt，在 LAION-aesthetics v2 5+ 上以 512x512 分辨率继续训练 595k step，使用了 Classifier Free Guidance 技术，以 10% 概率删除文本条件。</li>
</ul>
</li>
<li>sd-v1-5-inpainting.ckpt：<ul>
<li>复用 sd-v1-5.ckpt，在 LAION-aesthetics v2 5+ 上以 512x512 分辨率以 inpainting 训练了 440k step，使用 Classifier Free Guidance 技术，以 10% 概率删除文本条件。在 U-Net 的输入中额外加了 5 个 channel，4 个用于 masked 的图像，1 个用于 mask 本身。</li>
</ul>
</li>
</ul>
<h3 id="2-4-Stable-Diffusion-V2"><a href="#2-4-Stable-Diffusion-V2" class="headerlink" title="2.4 Stable Diffusion V2"></a>2.4 Stable Diffusion V2</h3><p>Stable Diffusion 的 V2 版本，由 Stability-AI 发布</p>
<p>V2 包含三个子版本，分别为 v2.0，v2.1 和 Stable UnCLIP 2.1：</p>
<ul>
<li>v2.0：<ul>
<li>发布于 2022 年 11 月，U-Net 模型和 V1.5 相同，Text encoder 模型换成了 OpenCLIP-ViT/H 中的 text encoder。</li>
<li>SD 2.0-base：分别率为 512x512</li>
<li>SD 2.0-v：基于 2.0-base 微调，分辨率提升到 768x768，同时利用 [2202.00512] Progressive Distillation for Fast Sampling of Diffusion Models 提出的技术大幅降低 Diffusion 的步数。</li>
<li>发布了一个文本引导的 4 倍超分模型。</li>
<li>基于 2.0-base 微调了一个深度信息引导的生成模型。</li>
<li>基于 2.0-base 微调了一个文本信息引导的修复模型。</li>
</ul>
</li>
<li>v2.1：<ul>
<li>发布于 2022 年 12 月，模型结构和参数量都和 v2.0 相同。并在 v2.0 的基础上使用 LAION 5B 数据集（较低的 NSFW 过滤约束）微调。同样包含 512x512 分辨率的 v2.1-base 和 768x768 分辨率的 v2.1-v。</li>
</ul>
</li>
<li>Stable UnCLIP 2.1：<ul>
<li>发布于 2023 年 3 月，基于 v2.1-v（768x768 分辨率） 微调，参考 OpenAI 的 DALL-E 2（也就是 UnCLIP），可以更好的实现和其他模型的联合，同样提供基于 CLIP ViT-L 的 Stable unCLIP-L 和基于 CLIP ViT-H 的 Stable unCLIP-H</li>
</ul>
</li>
</ul>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/640-20240117000025136.png" alt="图片"></p>
<p>从结果来看，V2版本相对于V1.5提升比较明显，但是实际体验效果比较一般，而且V2版本难以finetune。</p>
<h3 id="3-4-Stable-Diffusion-XL"><a href="#3-4-Stable-Diffusion-XL" class="headerlink" title="3.4  Stable Diffusion XL"></a>3.4  Stable Diffusion XL</h3><p>Stable Diffusion 的 XL 版本，由 Stability-AI 发布，位于代码库 Generative Models by Stability AI。</p>
<p>该版本发布于 2023 年 06 月，主要包含两个模型：</p>
<ul>
<li>SDXL-base-0.9：基于多尺度分辨率训练，最大分辨率 1024x1024，包含两个 Text encoder，分别为 OpenCLIP-ViT/G 和 CLIP-ViT/L。</li>
<li>SDXL-refiner-0.9：用来生成更高质量的图像，不应直接使用，此外文本条件只使用 OpenCLIP 中的 Text encoder。</li>
</ul>
<p>2023 年 07 月发布 1.0 版本，同样对应两个模型：</p>
<ul>
<li>SDXL-base-1.0：基于 SDXL-base-0.9 改进。</li>
<li>SDXL-refiner-1.0：基于 SDXL-refiner-0.9 改进。</li>
</ul>
<p>2023 年 11 月发表 SDXL-Trubo 版本，通过引入蒸馏技术来优化加速的版本。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/04/21/EVA02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/21/EVA02/" class="post-title-link" itemprop="url">EVA02解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-21 21:03:00" itemprop="dateCreated datePublished" datetime="2023-04-21T21:03:00+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-22 23:03:00" itemprop="dateModified" datetime="2023-04-22T23:03:00+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CV/" itemprop="url" rel="index"><span itemprop="name">CV</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="EVA-02-A-Visual-Representation-for-Neon-Genesis"><a href="#EVA-02-A-Visual-Representation-for-Neon-Genesis" class="headerlink" title="EVA-02: A Visual Representation for Neon Genesis"></a>EVA-02: A Visual Representation for Neon Genesis</h1><p>EVA02的目标是作为下一代的基于Transformer的视觉表示模型。</p>
<p>文章主要包含两个部分：1、对普通Vit的架构改进，2、MIM的预训练策略</p>
<p><strong>总结</strong></p>
<p>EVA02主要有两个改进，一是，通过实验的方法来观察采用哪些NLP方向关于Vit的改进；二是，增加视觉特征编码的容量以及增加训练的轮数和图像的size；</p>
<h2 id="1-Architecture"><a href="#1-Architecture" class="headerlink" title="1 Architecture"></a>1 Architecture</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230629182751431.png" alt="image-20230629182751431"></p>
<p>ViT主要由 MHSA（用于全局空间信息聚合）和 pointwise的FFNs（特征变换）交错组成。但是NLP方面很多针对ViT的修改没有在视觉上应用。作者做了一个实验来探索不同的修改带来的影响：</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230703191529244.png" alt="image-20230703191529244"></p>
<p><strong>Gelu</strong>: $GELU(x)=x * \phi(x),x \sim N(0,1)$</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/v2-0d8b979444f64ab49d4bc0f4199a15c2_r.jpg" alt="img"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/%E6%88%AA%E5%9B%BE20230914183157.png" alt="截图20230914183157"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/v2-e31b1e5b4333a90fbcca03c9a863a0c5_r.jpg" alt="img"></p>
<h2 id="2-pre-trainning-strategy"><a href="#2-pre-trainning-strategy" class="headerlink" title="2 pre-trainning strategy"></a>2 pre-trainning strategy</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230703195140612.png" alt="image-20230703195140612"></p>
<p><strong>MIM teacher model变大，训练的epoch也需要变多；</strong></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230703195449659.png" alt="image-20230703195449659"></p>
<p><strong>分辨率的增加以及在imgnet数据上的有监督ft也会增加性能</strong></p>
<p>预训练目标类似于 EVA [44]，即仅以可见图像块为条件回归屏蔽图像文本对齐的视觉特征。我们使用 [MASK] 标记破坏输入补丁，并按照 [5, 44] 使用掩码率为 40% 的分块掩码。</p>
<p>MIM 预训练的目标表示来自可公开访问的 EVA-CLIP [44] 视觉塔，具有 10 亿个参数。 EV A-02 的输出特征首先被归一化 [4]，然后通过线性层投影到与 EVA-CLIP 的视觉特征相同的维度。我们使用负余弦相似度作为损失函数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/03/21/EMA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/21/EMA/" class="post-title-link" itemprop="url">EMA原理和pytorch实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-21 21:03:00" itemprop="dateCreated datePublished" datetime="2023-03-21T21:03:00+08:00">2023-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-03-22 23:03:00" itemprop="dateModified" datetime="2023-03-22T23:03:00+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">训练技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="EMA的原理和pytorch实现"><a href="#EMA的原理和pytorch实现" class="headerlink" title="EMA的原理和pytorch实现"></a>EMA的原理和pytorch实现</h1><h2 id="EMA-定义"><a href="#EMA-定义" class="headerlink" title="EMA 定义"></a>EMA 定义</h2><p>指数移动平均也叫权重移动平均，是一种给予近期数据更高权重的平均方法。</p>
<h2 id="在深度学习的优化中的EMA"><a href="#在深度学习的优化中的EMA" class="headerlink" title="在深度学习的优化中的EMA"></a>在深度学习的优化中的EMA</h2><p>在深度学习的优化过程中，$\theta_t$ 是 t 时刻的模型权重 weight， $\upsilon_t$ 是 t 时刻的影子权重。在梯度下降的过程中，会一直维护着这个影子权重，但是这个影子权重不会参与训练。基本的假设是<strong>模型权重在最后 n 步内，会在实际的最优点处抖动，所以我们去最后 n 步的平均，能使模型更加的鲁棒。</strong></p>
<h3 id="EMA为何有效"><a href="#EMA为何有效" class="headerlink" title="EMA为何有效"></a>EMA为何有效</h3><p>因为在训练的时候，会使用验证集来衡量模型精度，但是验证集和测试集并不完全一致，在训练后期阶段，模型可能已经在测试集最佳精度附近波动，所以使用ema的结果会比使用单一结果更可靠。</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230307191607861.png" alt="image-20230307191607861"></p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/image-20230307191620727.png" alt="image-20230307191620727"></p>
<h3 id="Pytorch实现"><a href="#Pytorch实现" class="headerlink" title="Pytorch实现"></a>Pytorch实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EMA</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model, decay</span>):</span><br><span class="line">        self.model = model</span><br><span class="line">        self.decay = decay</span><br><span class="line">        self.shadow = &#123;&#125;</span><br><span class="line">        self.backup = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> name, param <span class="keyword">in</span> self.model.named_parameters():</span><br><span class="line">            <span class="keyword">if</span> param.requires_grad:</span><br><span class="line">                self.shadow[name] = param.data.clone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> name, param <span class="keyword">in</span> self.model.named_parameters():</span><br><span class="line">            <span class="keyword">if</span> param.requires_grad:</span><br><span class="line">                <span class="keyword">assert</span> name <span class="keyword">in</span> self.shadow</span><br><span class="line">                new_average = (<span class="number">1.0</span> - self.decay) * param.data + self.decay * self.shadow[name]</span><br><span class="line">                self.shadow[name] = new_average.clone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply_shadow</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> name, param <span class="keyword">in</span> self.model.named_parameters():</span><br><span class="line">            <span class="keyword">if</span> param.requires_grad:</span><br><span class="line">                <span class="keyword">assert</span> name <span class="keyword">in</span> self.shadow</span><br><span class="line">                self.backup[name] = param.data</span><br><span class="line">                param.data = self.shadow[name]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restore</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> name, param <span class="keyword">in</span> self.model.named_parameters():</span><br><span class="line">            <span class="keyword">if</span> param.requires_grad:</span><br><span class="line">                <span class="keyword">assert</span> name <span class="keyword">in</span> self.backup</span><br><span class="line">                param.data = self.backup[name]</span><br><span class="line">        self.backup = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">ema = EMA(model, <span class="number">0.999</span>)</span><br><span class="line">ema.register()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练过程中，更新完参数后，同步update shadow weights</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    optimizer.step()</span><br><span class="line">    ema.update()</span><br><span class="line"></span><br><span class="line"><span class="comment"># eval前，apply shadow weights；eval之后，恢复原来模型的参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>():</span><br><span class="line">    ema.apply_shadow()</span><br><span class="line">    <span class="comment"># evaluate</span></span><br><span class="line">    ema.restore()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/02/24/lora/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/24/lora/" class="post-title-link" itemprop="url">Lora</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-02-24 23:00:00 / Modified: 23:53:00" itemprop="dateCreated datePublished" datetime="2023-02-24T23:00:00+08:00">2023-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">训练技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LoRA"><a href="#LoRA" class="headerlink" title="LoRA"></a>LoRA</h1><p>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2106.09685">https://arxiv.org/abs/2106.09685</a><br>代码链接：<a target="_blank" rel="noopener" href="https://github.com/microsoft/LoRA">https://github.com/microsoft/LoRA</a></p>
<p>LoRA是一种finetune扩散模型的训练技术。通过对标准的checkpoint模型微小的修改，可以比checkpoint模型小10到100倍。LoRA的原理比较简单，原始全量的finetune其实就是在原始模型参数基础上加入增量$W=W_0+\Delta W$，那么我们可以通过冻结原始参数 $W_0$，并且把增量部分通过低秩分解方式进一步降低参数量级$\Delta W = A*B^T$, 原始参数的维度是 $d*d$, 则低秩分解后的参数量级是 $2*r*d$, 这里 $r&lt;&lt;d$， 因此可以起到大幅降低微调参数量级的效果。</p>
<p>和textula inversion一样，不能直接使用LoRA模型，需要和checkpoint文件一起使用。</p>
<h2 id="How-does-LoRA-work-in-Stable-diffusion？"><a href="#How-does-LoRA-work-in-Stable-diffusion？" class="headerlink" title="How does LoRA work in Stable diffusion？"></a>How does LoRA work in Stable diffusion？</h2><p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/45f7e2ce00c48b8c96e938c9fe8ed3d4.png" alt="image"></p>
<p>LoRA通过在checkpoint上做小的修改替换风格，具体而言修改的地方是UNet中的cross-attention层。该层是图像和文本prompt交界的层。LORA的作者们发现微调该部分足以实现良好的性能。</p>
<p>cross attention层的权重是一个矩阵，LoRA fine tune这些权重来微调模型。那么LoRA是怎么做到模型文件如此小？LoRA的做法是将一个权重矩阵分解为两个矩阵存储，能起到的作用可以用下图表示，参数量由(1000<em> 2000)减少到(1000</em> 2+2000*2), 大概300多倍！</p>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/10bbf49b2e9042779941c600a692d74dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="img"></p>
<p><strong>核心代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 初始化低秩矩阵A和B</span></span><br><span class="line">self.lora_A.update(nn.ModuleDict(&#123;adapter_name: nn.Linear(self.in_features, r, bias=<span class="literal">False</span>)&#125;))</span><br><span class="line">self.lora_B.update(nn.ModuleDict(&#123;adapter_name: nn.Linear(r, self.out_features, bias=<span class="literal">False</span>)&#125;))</span><br><span class="line">self.scaling[adapter_name] = lora_alpha / r</span><br><span class="line"></span><br><span class="line"><span class="comment">## 向前计算</span></span><br><span class="line">result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)</span><br><span class="line">result += (</span><br><span class="line">    self.lora_B[self.active_adapter](</span><br><span class="line">        self.lora_A[self.active_adapter](self.lora_dropout[self.active_adapter](x))</span><br><span class="line">    )</span><br><span class="line">    * self.scaling[self.active_adapter]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>alpha参数：alpha其实是个缩放参数，本质和learning rate相同。</p>
<h2 id="cross-attention"><a href="#cross-attention" class="headerlink" title="cross attention"></a>cross attention</h2><p>cross-attention是扩散模型中关键的技术之一，在LoRA中通过微调该模块，即可微调生成图片的样式，而在Hypernetwork中使用两个带有dropout和激活函数的全链接层，分别修改cross attention中的key和value，也可以定制想要的生成风格。可见cross attention的重要性。</p>
<p>在讲cross-attention之前，先看看经典的transformer中attention的含义，attnetion实际上用了三个QKV矩阵，来计算不同token之间的彼此的依赖关系，Q和K可以用来计算当前token和其他token的相似度，这个相似度作为权值对V进行加权求和，可以作为下一层的token。更通俗点说，Q和k的作用是用来在token之间搬运信息，而value本身就是从当前token当中提取出来的信息. 比较常见的是self-attention，该注意力是一个sequence内部不同token间产生注意力，而cross-attention的区别是在不同的sequence之间产生注意力。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jiechu520.github.io/2023/01/21/dali%E9%A2%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jie Chu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJ blog">
      <meta itemprop="description" content="日常笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CJ blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/21/dali%E9%A2%84%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">DALI加速图像数据预处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-01-21 23:03:00" itemprop="dateCreated datePublished" datetime="2023-01-21T23:03:00+08:00">2023-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">训练技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DALI预处理加速"><a href="#DALI预处理加速" class="headerlink" title="DALI预处理加速"></a>DALI预处理加速</h1><p>NVIDIA DALI 文档：<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/examples/general/data_loading/external_input.html">https://docs.nvidia.com/deeplearning/dali/user-guide/docs/examples/general/data_loading/external_input.html</a></p>
<p>安装：<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/installation.html#pip-official-releases">https://docs.nvidia.com/deeplearning/dali/user-guide/docs/installation.html#pip-official-releases</a></p>
<h2 id="1、DALI-pipeline"><a href="#1、DALI-pipeline" class="headerlink" title="1、DALI pipeline"></a>1、DALI pipeline</h2><p>DALI可以选择纯CPU加载和预处理或者CPU&amp;GPU混合加载，GPU加载。</p>
<p>在DALI中，任何数据处理任务都有一个称为 Pipeline 的对象， Pipeline 对象是类的实例<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/pipeline.html#nvidia.dali.Pipeline"><code>nvidia.dali.Pipeline</code></a>或派生类。</p>
<p>可以通过以下方式定义DALI Pipeline</p>
<ol>
<li>通过实现内部使用 DALI 运算符的函数并使用<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/pipeline.html#nvidia.dali.pipeline_def"><code>pipeline_def()</code></a>装饰器对其进行装饰。</li>
<li>通过<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/pipeline.html#nvidia.dali.Pipeline"><code>Pipeline</code></a>直接实例化对象、构建图形并使用<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/pipeline.html#nvidia.dali.Pipeline.set_outputs"><code>Pipeline.set_outputs()</code></a>.</li>
<li>通过从<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/pipeline.html#nvidia.dali.Pipeline"><code>Pipeline</code></a>类继承并覆盖<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/pipeline.html#nvidia.dali.Pipeline.define_graph"><code>Pipeline.define_graph()</code></a>（这是定义 DALI Pipelines 的传统方式）</li>
</ol>
<p><img src="https://vino-1316924433.cos.ap-beijing.myqcloud.com/%E6%88%AA%E5%9B%BE20230907195707.png" alt="截图20230907195707"></p>
<h2 id="2、图像分类的pipeline示例"><a href="#2、图像分类的pipeline示例" class="headerlink" title="2、图像分类的pipeline示例"></a>2、图像分类的pipeline示例</h2><p>所有操作均在GPU上，note：<strong>使用gpu进行预处理，会占用显存，模型越大占用越多，但是GPU利用率会一直保持在100%</strong>。模型较大不推荐使用GPU加载。</p>
<p><strong>使用纯CPU操作，数据处理的速度也比 torchvision快</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrainPipeline</span>(<span class="title class_ inherited__">Pipeline</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size, num_threads, device_id, data_root, img_size, n_holes, length, custom_cutout=<span class="literal">False</span></span>):</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">super</span>(TrainPipeline, self).__init__(batch_size, num_threads, device_id, prefetch_queue_depth=<span class="number">4</span>)</span><br><span class="line">        mode = <span class="string">&#x27;gpu&#x27;</span></span><br><span class="line">        self.decode = ops.decoders.Image(device=<span class="string">&#x27;mixed&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        self.img_size = img_size</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># readers.File类似torchvision.datasets.ImageFolder，dali还有其他高阶API，可自行研究使用</span></span><br><span class="line">        self.<span class="built_in">input</span> = ops.readers.File(file_root=data_root, random_shuffle=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># Resize</span></span><br><span class="line">        self.resize = ops.Resize(device=mode, resize_x=<span class="built_in">int</span>(img_size*<span class="number">1.2</span>), resize_y=<span class="built_in">int</span>(img_size*<span class="number">1.2</span>))</span><br><span class="line">        <span class="comment"># Randomcrop，类似于torchvision.transforms.RandomCrop</span></span><br><span class="line">        self.randomcrop = ops.RandomResizedCrop(device=mode, size=img_size, random_area=[<span class="number">0.3</span>, <span class="number">1.0</span>])</span><br><span class="line">        <span class="comment"># CropMirrorNormalize可以实现normalize和随机水平翻转，类似于torchvision.transforms.Normalize &amp; RandomHorizontalFlip</span></span><br><span class="line">        self.normalize = ops.CropMirrorNormalize(device=mode, mean=[<span class="number">0.5</span>*<span class="number">255</span>, <span class="number">0.5</span>*<span class="number">255</span>, <span class="number">0.5</span>*<span class="number">255</span>],</span><br><span class="line">                                                 std=[<span class="number">0.5</span>*<span class="number">255</span>, <span class="number">0.5</span>*<span class="number">255</span>, <span class="number">0.5</span>*<span class="number">255</span>])</span><br><span class="line">        <span class="comment"># 获取随机数</span></span><br><span class="line">        self.rng1 = ops.random.Uniform()</span><br><span class="line">        self.rng2 = ops.random.CoinFlip()</span><br><span class="line">        <span class="comment"># 实例化改变图片色彩的类，类似于torchvision.transforms.ColorJitter</span></span><br><span class="line">        self.colortwist = ops.ColorTwist(device=mode)</span><br><span class="line">        <span class="comment"># 实例化旋转图像的类，类似于torchvision.transforms.RandomRotation</span></span><br><span class="line">        self.rotate = ops.Rotate(device=mode, fill_value=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># gridmask，类似于cutout这种随机遮挡块操作</span></span><br><span class="line">        self.gridmask = ops.GridMask(device=mode)</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<p>如果需要自定义数据处理的函数，可参考一下方式。以cutout为例：cutout使用的是cpu处理了，如果是gpu处理的话，<strong>需要将numpy改成cupy，DALI原生支持的操作和数据增强挺丰富的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CUTOUT</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_holes, length</span>):</span><br><span class="line">        self.n_holes = n_holes</span><br><span class="line">        self.length = length</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, imgs</span>):</span><br><span class="line">        c, h, w = imgs.shape</span><br><span class="line">        mask = np.ones((h, w), np.float32)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(self.n_holes):</span><br><span class="line">            y = np.random.randint(h)</span><br><span class="line">            x = np.random.randint(w)</span><br><span class="line">            y1 = np.clip(y - self.length // <span class="number">2</span>, <span class="number">0</span>, h)</span><br><span class="line">            y2 = np.clip(y + self.length // <span class="number">2</span>, <span class="number">0</span>, h)</span><br><span class="line">            x1 = np.clip(x - self.length // <span class="number">2</span>, <span class="number">0</span>, w)</span><br><span class="line">            x2 = np.clip(x + self.length // <span class="number">2</span>, <span class="number">0</span>, w)</span><br><span class="line">            mask[y1: y2, x1: x2] = <span class="number">0.</span></span><br><span class="line">        mask = np.expand_dims(mask, <span class="number">0</span>).repeat(c, axis=<span class="number">0</span>)</span><br><span class="line">        imgs = imgs * mask</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> imgs</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后在上面的 TrainPipeline上加上下面这行,model 是 “cpu”</span></span><br><span class="line">    self.mask = ops.PythonFunction(device=<span class="string">&quot;cpu&quot;</span>, function=CUTOUT(n_holes, length), num_outputs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>图像分类数据加载的时候的调用方式：其他的Iterator可以参考 <a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/plugins/pytorch_tutorials.html">https://docs.nvidia.com/deeplearning/dali/user-guide/docs/plugins/pytorch_tutorials.html</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nvidia.dali.plugin.pytorch <span class="keyword">import</span> DALIClassificationIterator</span><br><span class="line"><span class="keyword">from</span> nvidia.dali.plugin.base_iterator <span class="keyword">import</span> LastBatchPolicy</span><br><span class="line"> </span><br><span class="line">pipe_train = TrainPipeline(batch_size, num_threads, device_id, data_root, img_size, n_holes, length,custom_cutout=custom_cutout)</span><br><span class="line">pipe_train.build()</span><br><span class="line">         </span><br><span class="line"><span class="comment"># DALIClassificationIterator: 返回pytorch tensor 形式是 (data and label) , 即DataLoader</span></span><br><span class="line">train_loader = DALIClassificationIterator(pipe_train, size=pipe_train.epoch_size(<span class="string">&#x27;Reader&#x27;</span>),last_batch_policy=LastBatchPolicy.PARTIAL, auto_reset=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Jie Chu</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
